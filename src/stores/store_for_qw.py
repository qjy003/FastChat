import copyimport reimport typing# 项目的包和模块导入from src.base.store import Storefrom src.utils import encrypt, extract_arabic_numbers, get_detail_address, is_digit_end, \    match_phone_and_landline_numbersMAP_KEY_UNIT = {    "发货地地址": "",    "月发货单量": "单",    "月物流费用": "元",    "当前使用的快递": "",    "物流服务类型": "",    "产品重量": "公斤"}REMIND_INFO_SIGN = "麻烦您再提供一下"REMIND_SPECIAL_SIGN = "例如仓储，整车，冷链，国际物流等"REMIND_CONCLUSION_SIGN = "您的基本物流信息目前总结为以下几点"COLLECT_INFO = [{'col_name': '公司名称', 'value': '客户所在公司的名称'},                # {'col_name': '联系人', 'value': '客户所提供的可进行联系的联系人的名字'},                {'col_name': '联系方式', 'value': '客户所提供的联系人的联系方式'},                # {'col_name': '托寄物', 'value': '客户的发货品类'},                {'col_name': '月发货单量', 'value': '每月的发货单量'},                {'col_name': '月物流费用', 'value': '月物流费用'},                # {'col_name': '产品价值', 'value': '单个产品的价格'},                # {'col_name': '产品重量', 'value': '单个产品的重量或者每单重量'},                {'col_name': '发货地地址', 'value': '发货地地址'},                {'col_name': '目前使用快递', 'value': '当前使用的快递'},                # {'col_name': '特殊物流服务类型', 'value': '客户选择的特殊物流服务类型'},                ]ARABIC_INFO = ['月物流费用', '月发货单量', '产品重量']class StoreForQW(Store):    """    对话应用内使用的逻辑及数据存储类。    本类继承自Store类，用于在对话应用中处理和维护数据。    """    def __init__(self):        # 初始化方法，设置默认的键值对和客户信息        self.key_values = {'托寄物': '火腿'}  # 默认的键值对，存储如物品等数据        self.customer_info = {}  # 存储客户信息的字典        self.info_confirm_result = 1  # 信息确认的结果        self.mobiles = []  # 在对话历史当中捕捉到的明文手机号    def update_key_values(self, key_values: typing.Dict):        """        更新当前维护的键值对数据。        参数:            key_values (dict): 要更新的键值对字典。        """        # 检查传入的key_values是否为字典类型        if not isinstance(key_values, dict):            return        # 如果当前键值对为空，直接赋值        if self.key_values is None:            if key_values:                self.key_values = key_values            return        # 遍历传入的键值对，更新或添加数据        for key, value in key_values.items():            # 如果是特殊物流服务类型，跳过不处理            if key == '特殊物流服务类型':                continue            # 如果已存在且新值为有效值，更新键值            if key in self.key_values and value not in ['', '无', '暂无']:                if value != self.key_values[key]:                    self.set_key_value(key, value)            # 如果不存在，直接设置键值            elif key not in self.key_values:                self.set_key_value(key, value)            # 不支持的情况，打印提示            else:                print("not supported: ", key, value)    def set_state(self, received_info):        """        将received_info赋值给store对象的key_values属性。        此方法用于重置或更新store对象中的数据状态。        参数:            received_info (dict): 需要用于重载数据的字典。        返回:            None        """        # 使用深拷贝来确保received_info中的数据不会被外部修改影响store对象        self.key_values = copy.deepcopy(received_info)    def set_key_value(self, key, value):        """        设置新的键值对。        如果键对应的是阿拉伯信息，且值中包含阿拉伯数字，则只保存第一个阿拉伯数字作为值；        否则，直接保存键值对。        Args:            key: 键，一个不可变的数据类型。            value: 值，可以是任意数据类型。        """        # 如果键在阿拉伯信息中，尝试提取值中的阿拉伯数字；如果没有阿拉伯数字或键不是阿拉伯信息，直接保存值        self.key_values[key] = value if key not in ARABIC_INFO else (            extract_arabic_numbers(value)[0] if len(extract_arabic_numbers(value)) > 0 else value)    def get_key_values(self):        """        获取当前类中的key_values字典。        遍历key_values字典，如果值以数字结尾并且键在MAP_KEY_UNIT中，则保持该键值对不变；        如果'联系方式'键存在，并且有已知的手机号码，则将手机号码列表转换成字符串赋值给'联系方式'键。        Returns:            dict: 包含键值对的字典。        """        # 遍历字典，检查值的格式并在必要时进行更新        for key, value in self.key_values.items():            # 如果值以数字结尾且键在特定的键映射中，保持原值不变            if is_digit_end(value) and key in MAP_KEY_UNIT:                self.key_values[key] = value  # 实际上这行代码没有改变任何东西，可以考虑移除        # 如果存在'联系方式'键，并且已经收集到手机号码，将这些号码以逗号分隔的形式更新到'联系方式'键        if '联系方式' in self.key_values and len(self.mobiles) > 0:            self.key_values['联系方式'] = ','.join(self.mobiles)        # 返回更新后的字典        return self.key_values    def get_conclude_info(self) -> str:        """        汇总并加密当前类中的key_values数据，生成确认信息的字符串。        遍历key_values字典，将非空的键值对格式化为有序列表的形式，并附加到确认信息字符串中。        最后调用encrypt_conversation方法对生成的确认信息字符串进行加密。        Returns:            str: 加密后的确认信息字符串。        """        conclude_info = '感谢您提供的物流信息，麻烦您确认一下以下信息是否正确?\n'  # 初始化确认信息字符串        index = 1  # 初始化列表索引        # 遍历字典，为每个非空的键值对生成格式化字符串并添加到确认信息中        for key, value in self.key_values.items():            if value != '':                conclude_info += f"{index}. {key}: {value}\n"  # 将键值对格式化为有序列表项                index += 1  # 列表索引递增        # 使用encrypt_conversation方法加密确认信息，并返回加密后的结果        return self.encrypt_conversation([conclude_info])[0]    # 获取询问信息的方法    def get_ask_info(self) -> tuple:        """        生成询问客户信息的语句。        返回:        - ask_info: 拼接好的询问语句        - ask_count: 需要询问的信息项数量        """        ask_info = ''  # 初始化询问信息字符串        # 从self.key_values中筛选出值为空或特定字符串的键        ask_items = [k for k, v in self.key_values.items() if v in ['', '暂无', '无']]        # 如果有多个需要询问的信息项        if len(ask_items) > 1:            index = 1  # 设置索引计数器            ask_info += '\n'  # 在询问信息前添加换行            # 遍历信息项，逐个添加到ask_info中，格式为序号. 信息项名称            for ask_item in ask_items:                ask_info += f'{index}. {ask_item}，\n'                index += 1        # 如果只有一个需要询问的信息项        elif len(ask_items) == 1:            ask_info = ask_items[0]  # 直接将信息项作为询问语句        else:            ask_info = ''  # 如果没有需要询问的信息项，则清空ask_info        # 返回询问语句和需要询问的信息项数量        return ask_info, len(ask_items)    # 生成问候回复的方法    def gen_greeting_reply(self, salesperson_name):        """        根据性别和客户来源生成问候语回复。        参数:        - salesperson_name: 运营账号的名称        在开场白阶段使用，用于与客户建立联系。        返回:        - greeting_reply: 生成的问候语回复        """        greeting_reply = f"老板，您好！我是京东物流企微运营{salesperson_name}，"        greeting_reply += "我们了解到您有发货需求，我们可以进一步沟通了解下您的情况，给您更加优惠的价格！"        # 添加请求客户提供信息的语句        greeting_reply += "\n 您方便提供下面的信息么？\n" + self.get_not_received_info()        return greeting_reply    # 获取需要收集的物流信息的方法    @staticmethod    def get_collect_info():        """        V2版本，获取当前对话中需要提取的关键物流信息。        返回:        - collected_info: 以逗号分隔的需要收集的信息名称字符串        """        # 遍历COLLECT_INFO列表，提取每个元素中的'col_name'值，并使用逗号拼接成字符串        return ",".join([val['col_name'] for val in COLLECT_INFO])    # 获取关键物流信息数量的静态方法    @staticmethod    def get_collect_info_num():        """        获取当前在聊天对话中需要提取的关键物流信息的数量。        返回:        - int: 关键物流信息的数量        """        # 返回COLLECT_INFO列表的长度，即关键物流信息的数量        return len(COLLECT_INFO)    # 生成关键物流信息检查提示词信息的方法    @staticmethod    def gen_info_check_laws():        """        获取关键物流信息的检查提示词信息        Returns:            str: 检查提示词信息字符串        """        info_check_laws = []  # 初始化提示词列表        # 遍历COLLECT_INFO字典，生成对应的检查提示词        for index, collect_info in enumerate(COLLECT_INFO, start=2):            # 月发货单量检查提示词            if collect_info['col_name'] == '月发货单量':                info_check_laws.append(                    f"{index}. 分析用户是否提供月发货单量信息，若提供，判断是否包含数值大小。" +                    "若不含数值，字段值设为空；若为数值范围，取最大值转为数字；否则，直接转为数字。"                )            # 月物流费用检查提示词            elif collect_info['col_name'] == '月物流费用':                info_check_laws.append(                    f"{index}. 分析用户是否提供月物流费用信息，若提供，判断是否包含数值大小。" +                    "若不含数值，字段值设为空；若为数字范围，取最大值转为元；否则，直接转为元。"                )            # 产品重量检查提示词            elif collect_info['col_name'] == '产品重量':                info_check_laws.append(                    f"{index}. 分析用户是否提供产品重量信息，若提供，判断是否包含数值大小。" +                    "若不含数值，字段值设为空；若为数字范围，取最大值转为公斤；否则，直接转为公斤。"                )            # 发货地地址检查提示词            elif collect_info['col_name'] == '发货地地址':                info_check_laws.append(                    f"{index}. 分析用户是否提供具体地址信息，若未提供，字段值设为空；否则，更新地址信息。"                )            # 公司名称检查提示词            elif collect_info['col_name'] == '公司名称':                info_check_laws.append(                    f"{index}. 分析用户是否提供公司名称信息，判断是否符合规范，若符合，更新字段值；否则，设为空。"                )            # 联系方式检查提示词            elif collect_info['col_name'] == '联系方式':                info_check_laws.append(                    f"{index}. 分析用户是否提供联系方式信息，若符合手机号标准，更新字段值；否则，设为空。"                )            # 其他信息检查提示词            else:                info_check_laws.append(                    f"{index}. 分析用户是否提供信息及其准确性，若未提供修正值，字段值设为空；否则，更新信息。"                )        # 将提示词列表拼接成字符串并返回        return '\n'.join(info_check_laws)    # 更新客户确认信息的意向    def update_info_confirm_result(self, info_confirm_result):        """        更新当前对象的客户确认信息意向结果        Args:            info_confirm_result (str): 客户确认信息的意向分析结果        Returns:            None: 无返回值，直接更新对象属性        """        self.info_confirm_result = info_confirm_result  # 更新对象的info_confirm_result属性    # 检查用户是否在对话中更新了信息    def check_info_update(self, tmp_data: dict, data: dict) -> bool:        """        检查用户在新一轮对话中是否更新了信息。        Args:            tmp_data (dict): 根据客户最新回复收集的数据。            data (dict): 根据客户完整历史对话收集的数据。        Returns:            bool: 如果信息有更新返回True，否则返回False。        """        # 遍历临时数据，检查是否有非空字段或详细的地址信息        for key, value in tmp_data.items():            if key == '发货地地址':                if get_detail_address(value):  # 如果获取到详细地址，则直接返回True                    return True                else:                    continue            if value != '':  # 如果存在非空字段，则返回True                return True        # 遍历完整数据，检查是否有阿拉伯数字提取或与关键值不同的非空字段        for key, value in data.items():            if key in ARABIC_INFO and value != '':  # 如果是包含阿拉伯数字的信息，尝试提取数字                values = extract_arabic_numbers(value)                value = values[0] if len(values) > 0 else ''            if key == '联系方式':                value = self.decrypt_conversation(value)  # 解密联系方式            if key == '发货地地址':                value = value if get_detail_address(value) else ''  # 如果有详细地址则保留，否则置空            if key in self.key_values and value != '' and self.key_values[key] != value:                # 如果关键值有更新，返回True                return True        return False  # 如果没有发现更新，返回False    # 输出客户的系统自带信息    def output_customer_info(self):        """        构造并返回客户系统自带信息的字符串。        Returns:            str: 客户信息的加密字符串，如果客户信息为空则返回空字符串。        """        if len(self.customer_info) > 0:            # 初始化客户信息字符串            customer_info = "User:我的信息是"            # 收集所有键值对，格式化为"键:值"的列表            info = [f"{key}:{value}" for key, value in self.customer_info.items()]            # 将信息列表连接到客户信息字符串，以逗号分隔            customer_info += ":" + ",".join(info)            # 加密客户信息并返回第一条记录            return self.encrypt_conversation([customer_info])[0]        else:            # 如果没有客户信息，返回空字符串            return ""    # 加密对话中的敏感信息，如电话号码    def encrypt_conversation(self, conversation):        """        对对话内容中的敏感信息进行加密处理。        Args:            conversation (list of str): 需要加密的对话内容列表。        Returns:            list of str: 加密后的对话内容列表。        """        encrypted_conversation = []  # 初始化加密后的对话内容列表        for chat_content in conversation:            # 匹配对话内容中的电话号码和座机号码            tmp_mobiles = match_phone_and_landline_numbers(chat_content)            encrypted_chat_content = chat_content  # 初始化加密后的单条对话内容            if len(tmp_mobiles) > 0:                # 将匹配到的电话号码添加到类属性中，用于后续处理                self.mobiles.extend(tmp_mobiles)                # 遍历匹配到的电话号码，替换原始对话内容中的电话号码为加密后的形式                for tmp_mobile in tmp_mobiles:                    encrypted_chat_content = encrypted_chat_content.replace(tmp_mobile, encrypt(tmp_mobile))            # 将加密后的单条对话内容添加到列表中            encrypted_conversation.append(encrypted_chat_content)        # 去除重复的电话号码，并更新类属性        self.mobiles = list(set(self.mobiles))        return encrypted_conversation  # 返回加密后的对话内容列表    # 将加密后的回复消息解密为原始消息    def decrypt_conversation(self, reply_message):        """        将加密后的回复消息通过替换方式解密为原始消息。        Args:            reply_message (str): 加密后的回复消息。        Returns:            str: 解密后的回复消息。        """        # 遍历存储在类属性中的所有电话号码        for mobile in self.mobiles:            # 生成每个电话号码的加密形式            encrypt_mobile = encrypt(mobile)            # 将加密后的电话号码替换回原始电话号码，实现解密            reply_message = reply_message.replace(encrypt_mobile, mobile)        # 返回解密后的回复消息        return reply_message    # 获取当前需要总结的信息数量    @staticmethod    def get_conclude_info_num():        """        获取当前需要总结的信息总数。        Returns:            int: 需要总结的信息数量。        """        return len(COLLECT_INFO)  # 返回信息总结列表的长度    # 以静态方法的形式获取指定角色的最后一条回复    @staticmethod    def retrieve_role_last_reply(conversation_history: list, role_name: str = "user") -> str:        """        在对话历史列表中查找并返回指定角色的最后一条回复。        Args:            conversation_history (list[str]): 对话历史记录列表。            role_name (str, optional): 角色名称，默认为"user"。        Returns:            str: 指定角色的最后一条回复，如果未找到则返回空字符串。        """        # 如果对话历史为空，直接返回空字符串        if len(conversation_history) <= 0:            return ''        # 从对话历史的末尾开始逆序遍历，查找以角色名开头的对话        for conversation in conversation_history[::-1]:            if conversation.lower().startswith(role_name.lower()):                return conversation  # 返回找到的最后一条角色回复        # 如果没有找到对应的回复，返回空字符串        return ''    # 获取当前尚未掌握的信息    def get_not_received_info(self):        """        生成当前还未掌握到的信息的字符串表示。        Returns:            str: 以列表形式拼接的未掌握信息，每条信息前带有序号。        """        # 如果self.key_values为空，则直接从COLLECT_INFO获取所有信息字段        if len(self.key_values) <= 0:            ask_info = [v.get('col_name') for v in COLLECT_INFO]        else:            # 否则，从self.key_values中筛选出尚未填写或标记为无的信息字段            ask_info = [k for k, v in self.key_values.items() if (re.findall("^暂无|无|''$", str(v)) or v == '')]        # 生成未掌握信息的句式，并添加序号        ask_info_strings = []        for i, ask_item in enumerate(ask_info, start=1):            ask_info_strings.append(f"{i}、{ask_item}:")        # 使用换行符\n将未掌握信息拼接成字符串        ask_info_str = '\n'.join(ask_info_strings)        return ask_info_str  # 返回拼接后的未掌握信息字符串    # 获取当前未收集到的信息数量    def get_not_received_info_num(self):        """        计算当前未收集到的信息总数。        Returns:            int: 未收集到的信息数量。        """        # 如果self.key_values为空，则所有信息都未收集        if len(self.key_values) <= 0:            ask_info = [v.get('col_name') for v in COLLECT_INFO]        else:            # 否则，筛选出标记为未收集或空值的信息字段            ask_info = [k for k, v in self.key_values.items() if (re.findall("^暂无|无|''$", str(v)) or v == '')]        # 返回未收集到的信息数量        return len(ask_info)    # 静态方法：根据是否为回复问题的标识，生成相应的回复提示    @staticmethod    def question_reply_prompt(is_reply_question):        """        根据是否能够回答问题，生成对应的回复提示。        Args:            is_reply_question (bool): 是否能够回答问题的标识。        Returns:            str: 对应的回复提示。        """        # 如果能够回答问题，返回基于参考知识的解答提示        if is_reply_question:            return "仅根据参考知识当中的内容来解答User的疑问"        else:            # 如果无法回答问题，返回道歉并告知无法解答的提示            return "向User回复不知道并道歉无法解答User的疑问和问题"