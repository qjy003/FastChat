import gradio as grimport fastapiimport timefrom fastapi import FastAPIfrom abc import ABC, abstractmethodfrom abc import ABCMetafrom src.config import *from typing import Optionalfrom typing import Listfrom typing import Dictfrom typing import Anyfrom src.base.store import Storefrom src.base.utils import request_chat_applicationfrom src.base.utils import add_call_func_2_logfrom src.base.utils import return_type_must_beROLE_MAPPING = {"机器人": "assistant", "User": "user"}class _DecorateAllMethods(type):    """A metaclass that decorates all methods of a subclass.    This metaclass iterates over all attributes of a class being created. If an attribute is a callable    (i.e., a method), it checks if the method is overriding a method from its base classes. If it is,    and if the method name matches specific criteria, it applies a decorator to the method. This approach    ensures that methods overriding abstract methods still retain the intended decorators from the superclass.    """    def __new__(mcs, name, bases, dct):        # Iterate over all attributes of the class        for attr, value in dct.items():            # Check if the attribute is a callable (i.e., likely a method)            if callable(value):                is_over_write = False                # Check if this method overrides a method from its base classes                for base in bases:                    if hasattr(base, attr) and getattr(base, attr) is not value:                        is_over_write = True                        break                # Apply specific decorators based on the method's name and whether it overrides a base class method                if attr == 'gen_request':                    dct[attr] = add_call_func_2_log(request_chat_application(add_call_func_2_log(value)))                if attr == 'process_inference_results':                    dct[attr] = add_call_func_2_log(value)                    # dct[attr] = request_chat_application(value)                if attr == 'set_store_class':                    dct[attr] = return_type_must_be(Store)(add_call_func_2_log(value))                if attr == 'update_store':                    dct[attr] = return_type_must_be(Store)(add_call_func_2_log(value))        # Create the new class with the possibly modified dictionary of attributes/methods        return super().__new__(mcs, name, bases, dct)class _CombinedMeta(ABCMeta, _DecorateAllMethods):    """    In order to avoid conflicts caused by other classes inherited by the class that are    not of the same origin as the primitive class, the primitive class and abstract class    ABCMeta are merged to avoid conflicts.    """    passclass FrontInterface(ABC, metaclass=_CombinedMeta):    """    本类提供了一个基础的前端界面的应用服务，用于实际体验对话应用服务    """    def clear_btn_clk(self):        pass    def like_btn_clk(self):        pass    def main(self):        """        Constructs and returns a Gradio Blocks interface for a conversational application.        This method creates a Gradio Blocks interface that simulates a chatbot conversation. It showcases a markdown        header with a brief description of the application, followed by a Chatbot component that interacts with the        user. The Chatbot is designed to recommend gym promotions and collect user information. Additionally, it        includes a Textbox for user input, a ClearButton to reset the conversation, and predefined examples of common        questions.        Returns:            demo: A Gradio Blocks interface object. This object encapsulates the entire conversational application,            including the chatbot, user input textbox, clear button, and examples of common questions. It is ready to be            served or integrated into a web application.        Note:            - The `gr.Blocks()` context manager is used to define the layout and components of the interface in a            structured manner.            - `gr.Markdown` is used to display introductory text or instructions in Markdown format.            - `gr.Chatbot` creates a chat interface where the bot and the user can exchange messages. The initial bot            message is generated by `self.gen_request([])`.            - User and assistant avatars are specified using `avatar_images`, with their paths constructed dynamically            from a predefined `MAIN_PATH` and specific filenames.            - `gr.Textbox` provides a field for users to input their questions or messages to the chatbot.            - `gr.ClearButton` is configured to clear both the textbox and chatbot history when clicked.            - `msg.submit` and `clear.click` link the textbox's submission and the clear button's click event to            specific callback functions, respectively, to process user input and clear the conversation.            - `chatbot.like` allows for the implementation of a feedback mechanism for the chatbot's responses.            - `gr.Examples` displays common questions that users can click on to quickly send predefined queries to the            chatbot.        Raises:            - This method does not explicitly raise exceptions but depends on the proper configuration of the Gradio            interface components and the correct implementation of callback functions like `self.gen_request` and `            self.clear_btn_clk`.        """        with gr.Blocks() as demo:            store = self.set_store_class()()            gr.Markdown(                f"""            # <center> {'对话应用示例' if not hasattr(self, 'module_name') else getattr(self, 'module_name')} </center>                """            )            chatbot = gr.Chatbot(                value=[[None, self.gen_request([], "", store)]],                avatar_images=(                    os.path.join(MAIN_PATH, f"image/user.png"),                    os.path.join(MAIN_PATH, f"image/assistant.png"),                ),                show_label=False,                show_copy_button=True,            )            reply = ""            reply_state = gr.State(value=reply)            store_state = gr.State(value=store)            with gr.Row():                msg = gr.Textbox(placeholder="输入回复内容", scale=12, show_label=False)                clear = gr.ClearButton([msg, chatbot], value="清除历史对话", scale=1)            msg.submit(self.chatbot_msg_clk, inputs=[msg, chatbot, reply_state, store_state],                       outputs=[msg, chatbot, reply_state, store_state]).then(                self.gen_request, inputs=[chatbot, reply_state, store_state],                outputs=[chatbot, reply_state, store_state]).then(                FrontInterface.assign_chat_bot, [chatbot, reply_state], chatbot            )            clear.click(self.clear_btn_clk, None, chatbot, queue=False)            chatbot.like(self.like_btn_clk, None, None)        return demo    def _setup_app(self, app=None):        """        Binds the application to the frontend service.        This method is responsible for integrating a given application with the frontend service. It checks if the        current object has an attribute named 'path'. If not, it raises a ValueError indicating that the 'path'        attribute is missing. If the 'path' attribute exists, it proceeds to mount the application using the specified        path. If no app is provided, it defaults to None, which implies that it might use a default or previously        defined application instance.        Args:            app: Optional. The application instance to be bound. If None, a default or pre-existing application instance             may be used. This parameter allows for flexibility in specifying the application to be bound to the             frontend service.        Returns:            The result of the `gr.mount_gradio_app()` function, which is typically an object representing the mounted            application. This return value signifies that the application has been successfully integrated with the            frontend service, making it accessible through the specified path.        Raises:            ValueError: If the current object does not have a 'path' attribute. This is critical for the integration            process as the 'path' determines where the application will be accessible from the frontend service.        Note:            - The `gr.mount_gradio_app()` function is assumed to be a part of an external library or framework            (presumably Gradio) that facilitates the integration of applications with a frontend interface. The actual            behavior and return value of this function may vary depending on the implementation details of the library.            - The 'path' attribute plays a crucial role in this method. It specifies the URL path at which the            application will be accessible. If not explicitly set, this method defaults to using '/' as the path,            which means the application will be mounted at the root of the frontend service's URL space.        """        if not hasattr(self, 'path'):            raise ValueError(f"The attribute path of {self.__class__.__name__} is missing")        return gr.mount_gradio_app(app, self.main(), path=getattr(self, 'path', '/'))    def setup_app(self, app: Optional[FastAPI] = None) -> FastAPI:        """        Binds the application service to the frontend service. Checks if the application exists;        if it does not, constructs the application first before performing the binding.        Args:            app: An optional FastAPI application instance. If not provided, a new FastAPI                 instance will be created.        Returns:            fastapi.FastAPI: The configured FastAPI application instance, ready for use.        """        if app is None:            app = FastAPI()        return self._setup_app(app)    @abstractmethod    def gen_request(self, chat_contents: List, user_reply: str, store: Store) -> Dict:        """        Implement this abstract method. The result of this method will be used as the request parameter        for the `inference` method of `chat_application`. Ensure that the parameters are defined in        coordination with the developers responsible for the chat application control center module.        Args:            store: The store of the front end            user_reply: The reply from the user            chat_contents: The chat contents where the messages are displayed.        Returns:            The request data that will be passed to the `chat_application.inference` method.        """        pass    @abstractmethod    def process_inference_results(self, inference_results: Any, store: Store) -> str:        """        Processes the results returned by the `chat_application`'s inference execution.        This method should appropriately handle the inference results, but note that the        return value will be output character by character to the frontend interface.        Therefore, the return result must be of string type.        Args:            store: the storage of the front end service.            inference_results: The results returned from the chat_application's inference method.        Returns:            str: A string representation of the processed inference results ready for frontend display.        """        pass    @staticmethod    def assign_chat_bot(chat_box, reply):        """        Simulates typing of a reply into the chat box and updates the chat box in real-time.        This function iterates through each character in the reply, appending it to the last        message in the chat box. It simulates the effect of typing by introducing a delay        between each character. This updated chat box is then yielded back for real-time        rendering on the conversation page.        Args:            chat_box (list): The chat box data structure, where each item is a message.                             The last item is assumed to be the current message being typed.            reply (str): The reply message to be typed into the chat box.        Yields:            list: The updated chat box with the new character of the reply added to the last message.        """        # Clear the content of the last message in the chat box.        chat_box[-1][1] = ""        # Iterate through each character in the reply.        for character in reply:            # Append the current character to the last message in the chat box.            chat_box[-1][1] += character            # Introduce a short delay to simulate typing speed.            time.sleep(0.05)            # Yield the updated chat box for real-time rendering.            yield chat_box    @staticmethod    def chatbot_msg_clk(user_message, history, reply_state, store):        return "", history + [[f"User: {user_message}", ""]], reply_state, store    @abstractmethod    def set_store_class(self) -> type:        """        Sets the class of the register object to be bound with the frontend interface.        This abstract method defines the signature for setting the class of the register object,        which is intended to be bound with a frontend interface. Implementations of this method        should return the class type of the register object that will be used for binding.        Returns:            type: The class of the register object to be bound with the frontend interface.        """        pass    @abstractmethod    def update_store(self, inference_results: Any, store: Store) -> Store:        """        Updates the `store` object with information deemed necessary for persistent storage        based on the results returned by the execution of the chat application.        This abstract method serves as a contract for subclasses to implement the logic of        updating the persistent storage (`store`) with information derived from the inference        results of the chat application. This could include saving conversation history, user        preferences, or any other relevant data that needs to be persisted.        Args:            inference_results (Any): The results obtained from the inference execution of the chat application.            store (Store): The persistent storage object where information is to be added or updated.        Returns:            Store: The updated `store` object after adding the necessary information from the inference results.        Note:            The actual implementation should handle the specifics of how the `store` is updated,            which may involve adding new data, updating existing records, or performing other            relevant persistence operations based on the `inference_results`.        """        pass