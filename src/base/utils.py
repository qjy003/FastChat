import reimport astimport warningsimport inspectimport copyimport uvicornimport aiohttpimport asyncioimport jsonimport loggingimport base64import timeimport typingimport richimport osimport coloramafrom tqdm import tqdmfrom tabulate import tabulatefrom functools import wrapsfrom typing import Dict, Listfrom pyfiglet import figlet_formatfrom src.base.log import Loggerfrom datetime import datetime, timedeltafrom typing import Anyfrom pydantic import BaseModelfrom fastapi.params import File as FileTypefrom fastapi.params import Form as FormTypefrom pydantic.fields import FieldInfofrom fastapi.datastructures import UploadFilefrom loguru import logger as sloggerfrom src.base.es_log import Logger as ESLoggerfrom apscheduler.triggers.date import DateTriggerfrom src.config import *def extract_prompt_placeholders(prompt: str) -> list:    """    Extracts the names of all placeholders from the provided prompt string.    Args:        prompt (str): The original prompt string containing placeholders.    Returns:        list: A list of unique placeholder names found in the prompt.    """    pattern = r'\{([^}]*)\}'    matches = re.findall(pattern, prompt)    unique_placeholders = list(set(matches))    return unique_placeholdersdef store_result_in_attribute(attribute_name: str):    """    Decorator that stores the result of the decorated method in an attribute of the class    instance.    If the attribute already exists, a warning is issued.    Args:        attribute_name (str): The name of the attribute to store the result in.    Returns:        Callable: A decorator function.    """    def decorator(func):        @wraps(func)        def wrapper(self, *args, **kwargs):            if hasattr(self, attribute_name):                warnings.warn(f"Attribute '{attribute_name}' already exists in '{self.__class__.__name__}' "                              f"and will be overwritten.", UserWarning)            result = func(self, *args, **kwargs)            setattr(self, attribute_name, result)            return result        return wrapper    return decoratordef async_return_type_must_be(return_type: type):    """    Decorator that enforces the return type of the decorated method.    Args:        return_type (type): The expected return type of the decorated method.    Returns:        Callable: A decorator function.    """    def decorator(func):        async def wrapper(*args, **kwargs):            result = await func(*args, **kwargs)            if not isinstance(result, type) and not isinstance(result, return_type):                raise ValueError(f"Function {func.__name__} must return {return_type.__name__}, "                                 f"not {type(result).__name__}")            if isinstance(result, type) and not issubclass(result, return_type):                raise ValueError(f"Function {func.__name__} must return {return_type.__name__}, "                                 f"not {type(result).__name__}")            return result        return wrapper    return decoratordef return_type_must_belong(return_types: list):    """    Decorator that enforces the return type of the decorated method.    Args:        return_types (type): The expected return type of the decorated method.    Returns:        Callable: A decorator function.    """    def decorator(func):        def wrapper(*args, **kwargs):            result = func(*args, **kwargs)            is_belong = False            for return_type in return_types:                if not isinstance(result, type) and isinstance(result, return_type):                    # raise ValueError(f"Function {func.__name__} must return {return_type.__name__}, "                    #                  f"not {type(result).__name__}")                    is_belong = True                if isinstance(result, type) and issubclass(result, return_type):                    # raise ValueError(f"Function {func.__name__} must return {return_type.__name__}, "                    #                  f"not {type(result).__name__}")                    is_belong = True            if not is_belong and not isinstance(result, type):                raise ValueError(                    f"Function {func.__name__} must return {''.join([return_type.__name__ for return_type in return_types])}, "                    f"not {type(result).__name__}")            if not is_belong and isinstance(result, type):                raise ValueError(                    f"Function {func.__name__} must return {''.join([return_type.__name__ for return_type in return_types])}, "                    f"not {type(result).__name__}")            return result        return wrapper    return decoratordef return_type_must_be(return_type: type):    """    Decorator that enforces the return type of the decorated method.    Args:        return_type (type): The expected return type of the decorated method.    Returns:        Callable: A decorator function.    """    def decorator(func):        def wrapper(*args, **kwargs):            result = func(*args, **kwargs)            if not isinstance(result, type) and not isinstance(result, return_type):                raise ValueError(f"Function {func.__name__} must return {return_type.__name__}, "                                 f"not {type(result).__name__}")            if isinstance(result, type) and not issubclass(result, return_type):                raise ValueError(f"Function {func.__name__} must return {return_type.__name__}, "                                 f"not {type(result).__name__}")            return result        return wrapper    return decoratordef input_type_must_be(map_variable_2_type: Dict):    """    Decorator that enforces the input variable types of the decorated method.    Args:        map_variable_2_type: The relationship of a variable to its qualified variable required_type.    Returns:        Callable: A decorator function.    """    def decorator(func):        def wrapper(self, *args, **kwargs):            for i, variable in enumerate(map_variable_2_type.keys()):                if variable not in kwargs and len(args) > i:                    kwargs[variable] = args[i]            for variable, required_type in map_variable_2_type.items():                if variable not in kwargs:                    raise ValueError(f"The required parameter {variable} of {func.__name__} is missing")                if not isinstance(kwargs.get(variable), required_type):                    raise ValueError(f"Function {func.__name__} must return {required_type.__name__}, "                                     f"not {type(kwargs.get(variable)).__name__}")            result = func(self, *args, **kwargs)            return result        return wrapper    return decoratordef process_inference_result(method):    """    Decorator that processes the result of the decorated method by executing a    `process_inference_results` method.    Args:        method (Callable): The method being decorated.    Returns:        Callable: The decorated method.    """    def wrapper(self, *args, **kwargs):        result = method(self, *args, **kwargs)        if not hasattr(self, 'process_inference_results'):            raise AttributeError(f"{self.__class__.__name__} does not have a method named "                                 f"'process_inference_results'")        if result is not None:            result = self.process_inference_results(inference_results=result)        return result    return wrapperdef async_process_inference_result(method):    """    Decorator for async methods that processes the result by executing a    `process_inference_results` method asynchronously.    Args:        method (Callable): The async method being decorated.    Returns:        Callable: The decorated async method.    """    async def wrapper(self, *args, **kwargs):        result = await method(self, *args, **kwargs)        if not hasattr(self, 'process_inference_results'):            raise AttributeError(f"{self.__class__.__name__} does not have a method named"                                 f" 'process_inference_results'")        if result is not None:            result = self.process_inference_results(inference_results=result)        return result    return wrapperdef then_execute_initialize(method):    """    Decorator that executes the `initialize` method of the class after the decorated method.    Args:        method (Callable): The method being decorated.    Returns:        Callable: The decorated method.    """    def wrapper(self, *args, **kwargs):        result = method(self, *args, **kwargs)        if not hasattr(self, 'initialize'):            raise AttributeError(f"'{self.__class__.__name__}' object has no attribute "                                 f"'initialize'")        self.initialize()        return result    return wrapperdef check_return_in_chat_modules(method):    """    Decorator factory for checking whether the return value of a class method is a    conversation stage in self.reply_modules.    Args:        method (Callable): The method being decorated.    Returns:        Callable: The decorated method.    """    def wrapper(self, *args, **kwargs):        # execute original method        result = method(self, *args, **kwargs)        # Check if the return value is in the key of self.reply_modules        if result not in self.reply_modules and result != "":            raise ValueError(f"Return value '{result}' is not a key in self.reply_modules")        return result    return wrapperdef then_call_process_think_results(method):    """Decorates a method to call `process_think_results` after its execution.    This decorator is designed to augment a method such that immediately after    its execution, the `process_think_results` method of the same class is called    with the result of the decorated method. The `process_think_results` method    is expected to process or modify the result before returning it.    Args:        method (Callable): The method to be decorated.    Returns:        Callable: A wrapper function that, when called, executes the original method,        then calls `process_think_results` with the method's result, and finally        returns the processed result.    """    async def wrapper(self, *args, **kwargs):        # Execute the decorated method and store its result.        result = await method(self, *args, **kwargs)        # Call the `process_think_results` method of the current instance (`self`),        is_return_async_tasks = kwargs.get('is_return_async_tasks', args[1] if len(args) > 1 else False)        if is_return_async_tasks:            return result        # passing the original method's result as an argument, and update the `result`        # with the processed value.        self.process_think_results(think_results=result, **kwargs)        # Return the processed result.        return result    return wrapperdef convert_async_2_normal(f):    """A decorator that converts the result of an async function into a synchronous return variable.    This decorator wraps an asynchronous function, allowing it to be called in a synchronous    manner by running the event loop until the future completes and returning the result.    Args:        f (Callable): The asynchronous function to be wrapped.    Returns:        Callable: A wrapper function that can be called synchronously.    """    async def wrapper(self, *args, **kwargs):        # Call the original asynchronous function with await and return its result.        return await f(self, *args, **kwargs)    def sync_wrap(self, *args, **kwargs):        # Use asyncio.run() to run the async wrapper function in an event loop until it completes.        # This effectively makes the asynchronous function call synchronous.        is_return_async_tasks = kwargs.get('is_return_async_tasks', False)        if is_return_async_tasks:            return wrapper(self, *args, **kwargs)        return asyncio.run(wrapper(self, *args, **kwargs))    sync_wrap.__name__ = f.__name__    return sync_wrapdef then_call_evaluate_reply_results(method):    """    Decorates a method to evaluate the safety and quality of replies generated by a dialogue module.    This decorator augments a method by adding a post-execution step that evaluates the safety and    quality of the method's output (presumably, replies generated by a dialogue module). It uses    the `evaluate_reply_results` method of the same class to perform this evaluation. The decorated    method's output is then returned along with the evaluation result, providing both the reply and    its assessed safety level.    Args:        method (Callable): The method to be decorated, expected to generate a reply.    Returns:        Callable: A wrapper function that, when called, executes the original method to generate a reply,        evaluates the reply's safety and quality, and returns the reply along with its safety level.    """    async def wrapper(self, *args, **kwargs):        # Execute the decorated method and store its result (the generated reply).        result = await method(self, *args, **kwargs)        # Evaluate the safety and quality of the generated reply using the class's        # `evaluate_reply_results` method. The evaluation result is stored in `safe_level`.        safe_level = self.evaluate_reply_results(result, *args, **kwargs)        # Return both the original reply and its evaluated safety level.        return result, safe_level    return wrapperdef then_call_process_inference_results(method):    """    Decorates a method to process its inference results into a business-specific format.    This decorator enhances a method by adding a post-execution step that processes the method's    inference results. The processing is aimed at transforming the results into a format that meets    specific business requirements. It leverages the `process_inference_results` method of the same    class to perform this transformation. The decorator allows for seamless integration of result    processing within the method's workflow, ensuring that the output directly aligns with business    needs.    Args:        method (Callable): The method to be decorated, expected to produce inference results.    Returns:        Callable: A wrapper function that, upon invocation, executes the original method to generate        inference results, processes these results into the desired business format using the class's        `process_inference_results` method, and returns the processed results.    """    def wrapper(self, *args, **kwargs):        # Execute the decorated method and store its inference results.        result = method(self, *args, **kwargs)        # Process the inference results using the class's `process_inference_results`        # method. The processing is designed to transform the results into a format        # that meets specific business requirements. Additional arguments can be passed        # to tailor the processing as needed.        result = self.process_inference_results(reply_results=result[0], think_results=result[1], *args, **kwargs)        # Return the processed results, now in a format aligned with business needs.        return result    return wrapperdef first_call_initialize(method):    """    A decorator that ensures an initialization routine is run before the first call to the decorated method.    This decorator wraps a method to ensure that `self.initialize()` is called before the method itself is called.    This is useful for performing setup or initialization tasks for an object before its main functionality is accessed.    Args:        method: The method to be decorated.    Returns:        The wrapped method with initialization ensured.    """    def wrapper(self, *args, **kwargs):        # Ensure the initialization routine of the object is called.        self.initialize()        # Call the original method and return its result.        result = method(self, *args, **kwargs)        return result    return wrapperdef print_info_after_run(method):    """    Decorator to print core interface service information after the dialogue application starts.    Args:        method (function): The method to be decorated.    Returns:        function: The decorated method.    """    # Define the wrapper function that will be used as the decorator    def wrapper(self, *args, **kwargs):        # Execute the original method and store the result        result = method(self, *args, **kwargs)        # Initialize colorama to add colors to the terminal output        colorama.init()        # Create an ASCII art from text using pyfiglet        text = "FastChat"        art = figlet_format(text, font='slant')        main_color = colorama.Fore.BLUE        special_color = colorama.Fore.YELLOW        # Colorize the ASCII art        blue_art = main_color + art + colorama.Style.RESET_ALL        print(blue_art)        # Thinks the users use our structures in their projects        print(main_color + "Thanks for building your App based on the" + colorama.Style.RESET_ALL +              special_color + f" {text}-1.0 " + colorama.Style.RESET_ALL +              main_color + "developing structure. and" + colorama.Style.RESET_ALL+              special_color+ f" {self.workers} " + colorama.Style.RESET_ALL+              main_color + "workers stars up successfully." + colorama.Style.RESET_ALL)        # Print a success message with the application name        print(            main_color + f"Your chat application " + colorama.Style.RESET_ALL +            special_color + f"{self.application_name}" + colorama.Style.RESET_ALL +            main_color + " now starts successfully. The services info is shown below." +colorama.Style.RESET_ALL)        # Define headers for the table        headers = ['name', 'type', 'url']        # Collect data for the table from the application's interfaces        data = []        for interface_name, interface in self.http_interfaces.items():            data.append([interface_name, 'http', f"http://0.0.0.0:{self.port}" + interface.path])        for interface_name, interface in self.front_interfaces.items():            data.append([interface_name, 'front', f"http://0.0.0.0:{self.port}" + interface.path])        # Create a table using tabulate with grid format        table = tabulate(data, headers=headers, tablefmt='grid')        # Print the table with colorized headers        print(main_color + table + colorama.Style.RESET_ALL)        print(f"{main_color}Anything wrong please contact us by{colorama.Style.RESET_ALL} "              f"{special_color} qiaojiayang1@jd.com {colorama.Style.RESET_ALL}"              f"{main_color}.{colorama.Style.RESET_ALL}")        # Return the result from the original method        uvicorn.run(self.app, host="0.0.0.0", port=self.port, workers=self.workers)        return result    # Return the wrapper function    return wrapperdef log_reply_think(func):    """    Decorator function to log the result and composed prompt after executing the wrapped function.    This decorator logs the status of the function execution along with the composed prompt    and additional information. It assumes that the `get_composed_prompt` method and the    `Logger` class are already defined.    Args:        func (callable): The function to be wrapped.    Returns:        wrapper (callable): The wrapped function.    """    async def wrapper(self, *args, **kwargs):        """        The wrapper function that logs the result and composed prompt.        This function executes the original function with the provided arguments and logs        the result, composed prompt, and other relevant information.        Args:            self: The instance of the class the decorator is used in.            *args: Variable length argument list.            **kwargs: Arbitrary keyword arguments.        Returns:            result: The result of the original function.        """        # Execute the original function with the provided arguments        start_time = datetime.now()        result, flag = func(self, *args, **kwargs)        end_time = datetime.now()        spent_time = (end_time - start_time).seconds        # Retrieve the composed prompt using the chatbot's chain        composed_prompt = await self.chatbot.chain.get_composed_prompt(**kwargs)        # Initialize the logger with the application name        logger = Logger(application_name=self.application_name)        # Write the log entry with the status, composed prompt, and other details        logger.write(status=('success' if flag else 'fail'),                     composed_prompt=composed_prompt,                     module_name=self.module_name,                     # Assuming there's a typo in the original code: moudle_name -> module_name                     module_type=self.module_type,                     inference_result=result,                     spent_time=spent_time)        # Return the result of the original function        return await result    # Return the wrapper function    return wrapperdef async_log_reply_think(func):    """    Decorator function to log the result and composed prompt after executing the wrapped function.    This decorator logs the status of the function execution along with the composed prompt    and additional information. It assumes that the `get_composed_prompt` method and the    `Logger` class are already defined.    Args:        func (callable): The function to be wrapped.    Returns:        wrapper (callable): The wrapped function.    """    async def wrapper(self, *args, **kwargs):        """        The wrapper function that logs the result and composed prompt.        This function executes the original function with the provided arguments and logs        the result, composed prompt, and other relevant information.        Args:            self: The instance of the class the decorator is used in.            *args: Variable length argument list.            **kwargs: Arbitrary keyword arguments.        Returns:            result: The result of the original function.        """        # Execute the original function with the provided arguments        start_time = datetime.now()        result, flag = await func(self, *args, **kwargs)        end_time = datetime.now()        spent_time = (end_time - start_time).seconds        # Retrieve the composed prompt using the chatbot's chain        composed_prompt = await self.chatbot.chain.get_composed_prompt(**kwargs)        # Initialize the logger with the application name        logger = Logger(application_name=self.application_name)        # Write the log entry with the status, composed prompt, and other details        logger.write(status=('success' if flag else 'fail'),                     composed_prompt=composed_prompt,                     module_name=self.module_name,                     # Assuming there's a typo in the original code: moudle_name -> module_name                     module_type=self.module_type,                     inference_result=result,                     spent_time=spent_time)        # Return the result of the original function        return result    # Return the wrapper function    return wrapperdef request_chat_application(method):    """    Decorator that sends the return result of the decorated method as a request to the chat application.    The result is then received and processed by the frontend method `process_inference_results`.    Args:        method: The method to be decorated.    Returns:        The wrapper function that handles the decoration logic.    """    def wrapper(self, *args, **kwargs):        # Invoke the original method first        original_result = method(self, *args, **kwargs)        # Ensure that `self.chat_application` exists and has an `inference` method        if hasattr(self, 'chat_application') and hasattr(self.chat_application, 'inference'):            chat_box = args[0]            reply = args[1]            store = args[2]            if len(args) > 3:                image_path = args[3]            # Check if the original result is of type dict            if not isinstance(original_result, dict):                raise TypeError(f"{method.__name__} must return a {dict.__name__} type result.")            # Pass the return value of the original method as arguments to `self.chat_application.inference`            inference_result = asyncio.run(self.chat_application.request_preprocess(**original_result))            store = self.update_store(inference_results=inference_result,                                      store=store)            if not hasattr(self, 'process_inference_results'):                raise AttributeError(f"You have not realized the abstract method process_inference_results.")            # Return the result of `self.chat_application.inference`            robot_reply = self.process_inference_results(inference_result, store)            if not isinstance(reply, str):                raise TypeError(f"process_inference_results must return {str.__name__} type result, "                                f"not {type(reply).__name__} type.")            # If chat_box is not empty, simulate typing the reply            if len(chat_box) > 0:                if len(args) > 3:                    return chat_box, robot_reply, store, image_path                else:                    return chat_box, robot_reply, store            else:                return robot_reply        else:            # Raise an exception if the necessary attributes or methods are not found            raise AttributeError("The 'chat_application' or 'inference' method is not found.")            # Uncomment the following line if you want to return the original result even if there's no `inference`            # method            # return original_result    wrapper.__name__ = 'request_chat_application'    return wrapperdef check_variable_type(variable: Any, target_type: type):    """    Checks if the given variable is of the specified target type.    Args:      variable (Any): The variable to check the type of.      target_type (type): The expected type that the variable should be.    """    # If the variable is not an instance of the target type, raise a TypeError.    if not isinstance(variable, target_type):        # Constructs an error message that includes the actual type and the expected type.        raise TypeError(            f"the type {type(variable).__name__} is wrong, type {target_type.__name__} is needed."        )def then_call_process_query_results(method):    """    Decorates a method to process its inference results into a business-specific format.    This decorator enhances a method by adding a post-execution step that processes the method's    inference results. The processing is aimed at transforming the results into a format that meets    specific business requirements. It leverages the `process_inference_results` method of the same    class to perform this transformation. The decorator allows for seamless integration of result    processing within the method's workflow, ensuring that the output directly aligns with business    needs.    Args:        method (Callable): The method to be decorated, expected to produce inference results.    Returns:        Callable: A wrapper function that, upon invocation, executes the original method to generate        inference results, processes these results into the desired business format using the class's        `process_inference_results` method, and returns the processed results.    """    def wrapper(self, *args, **kwargs):        # Execute the decorated method and store its inference results.        result = method(self, *args, **kwargs)        # Process the inference results using the class's `process_inference_results`        # method. The processing is designed to transform the results into a format        # that meets specific business requirements. Additional arguments can be passed        # to tailor the processing as needed.        result = self.process_inference_results(query_content=result[0], query_results=result[1])        # Return the processed results, now in a format aligned with business needs.        return result    return wrapperdef async_then_call_process_query_results(method):    """    Decorates a method to process its inference results into a business-specific format.    This decorator enhances a method by adding a post-execution step that processes the method's    inference results. The processing is aimed at transforming the results into a format that meets    specific business requirements. It leverages the `process_inference_results` method of the same    class to perform this transformation. The decorator allows for seamless integration of result    processing within the method's workflow, ensuring that the output directly aligns with business    needs.    Args:        method (Callable): The method to be decorated, expected to produce inference results.    Returns:        Callable: A wrapper function that, upon invocation, executes the original method to generate        inference results, processes these results into the desired business format using the class's        `process_inference_results` method, and returns the processed results.    """    async def wrapper(self, *args, **kwargs):        # Execute the decorated method and store its inference results.        result = await method(self, *args, **kwargs)        # Process the inference results using the class's `process_inference_results`        # method. The processing is designed to transform the results into a format        # that meets specific business requirements. Additional arguments can be passed        # to tailor the processing as needed.        result = self.process_query_results(query_content=result[0], query_results=result[1])        # Return the processed results, now in a format aligned with business needs.        return result    return wrapperdef then_call_app_process_query_results(method):    """    Decorates a method to process its inference results into a business-specific format.    This decorator enhances a method by adding a post-execution step that processes the method's    inference results. The processing is aimed at transforming the results into a format that meets    specific business requirements. It leverages the `process_inference_results` method of the same    class to perform this transformation. The decorator allows for seamless integration of result    processing within the method's workflow, ensuring that the output directly aligns with business    needs.    Args:        method (Callable): The method to be decorated, expected to produce inference results.    Returns:        Callable: A wrapper function that, upon invocation, executes the original method to generate        inference results, processes these results into the desired business format using the class's        `process_inference_results` method, and returns the processed results.    """    async def wrapper(self, *args, **kwargs):        # Execute the decorated method and store its inference results.        knowledge_database_module_names = kwargs.get('knowledge_database_module_names',                                                     args[1] if len(args) > 1 else None)        is_return_async_tasks = kwargs.get('is_return_async_tasks', args[2] if len(args) > 2 else None)        result = await method(self, knowledge_database_module_names, **kwargs)        # Process the inference results using the class's `process_inference_results`        # method. The processing is designed to transform the results into a format        # that meets specific business requirements. Additional arguments can be passed        # to tailor the processing as needed.        if is_return_async_tasks:            return result        result = self.process_query_results(query_results=result, **kwargs)        # Return the processed results, now in a format aligned with business needs.        if isinstance(result, dict):            kwargs.update(result)        return kwargs    return wrapperdef then_call_update_reply_stage(method):    """    Decorates a method to process its inference results into a business-specific format.    This decorator enhances a method by adding a post-execution step that processes the method's    inference results. The processing is aimed at transforming the results into a format that meets    specific business requirements. It leverages the `process_inference_results` method of the same    class to perform this transformation. The decorator allows for seamless integration of result    processing within the method's workflow, ensuring that the output directly aligns with business    needs.    Args:        method (Callable): The method to be decorated, expected to produce inference results.    Returns:        Callable: A wrapper function that, upon invocation, executes the original method to generate        inference results, processes these results into the desired business format using the class's        `process_inference_results` method, and returns the processed results.    """    def wrapper(self, *args, **kwargs):        # Execute the decorated method and store its inference results.        kwargs = method(self, *args, **kwargs)        # Process the inference results using the class's `process_inference_results`        # method. The processing is designed to transform the results into a format        think_results = kwargs.get('think_results', None)        query_results = kwargs.get('query_results', None)        # that meets specific business requirements. Additional arguments can be passed        # to tailor the processing as needed.        is_decorate = kwargs.get('is_decorate', True)        if not is_decorate:            return kwargs        result = self.update_reply_stage(think_results=think_results, query_results=query_results, **kwargs)        # Return the processed results, now in a format aligned with business needs.        return result    return wrapperdef then_call_process_and_update_reply_stage(method):    """    Decorates a method to process its inference results into a business-specific format.    This decorator enhances a method by adding a post-execution step that processes the method's    inference results. The processing is aimed at transforming the results into a format that meets    specific business requirements. It leverages the `process_inference_results` method of the same    class to perform this transformation. The decorator allows for seamless integration of result    processing within the method's workflow, ensuring that the output directly aligns with business    needs.    Args:        method (Callable): The method to be decorated, expected to produce inference results.    Returns:        Callable: A wrapper function that, upon invocation, executes the original method to generate        inference results, processes these results into the desired business format using the class's        `process_inference_results` method, and returns the processed results.    """    async def wrapper(self, *args, **kwargs):        # Execute the decorated method and store its inference results.        result = await method(self, *args, **kwargs)        # Process the inference results using the class's `process_inference_results`        # method. The processing is designed to transform the results into a format        think_results = result[0]        query_results = result[1]        # that meets specific business requirements. Additional arguments can be passed        think_results = self.process_think_results(think_results=think_results, is_decorate=False, **kwargs)        query_results = self.process_query_results(query_results=query_results, is_decorate=False, **kwargs)        # to tailor the processing as needed.        result = self.update_reply_stage(think_results=think_results, query_results=query_results, **kwargs)        # Return the processed results, now in a format aligned with business needs.        return result    return wrapperdef get_dict_value(source_dict: dict, paths: list):    """    Retrieves a value from a nested dictionary using a specified path. If the specified path does not lead to a value,    the function attempts to retrieve the value using the last element of the paths list as a key from the current    level,    and continues to do so until a value is found or it is determined that no such value exists. The elements in the    paths    list represent keys at each level of the dictionary, from outer to inner.    Args:        source_dict (dict): The source dictionary from which to retrieve the value.        paths (list[str]): A list of strings representing the path of keys to the desired value within the dictionary.    Returns:        The value from the dictionary at the specified path, or an empty string if no such value exists.    """    def get_value(d: dict, keys: list):        """        A helper function that recursively searches for a value in the dictionary using the keys provided.        Args:            d (dict): The current dictionary or sub-dictionary being searched.            keys (list[str]): The remaining keys representing the path to the desired value.        Returns:            The value found at the specified path within the dictionary, or None if the path does not exist.        """        # Check if the first key is in the dictionary        if keys[0] in d:            # If the value for this key is another dictionary, recurse with the sub-dictionary and the remaining keys            if isinstance(d[keys[0]], dict):                tmp_result = get_value(d[keys[0]], keys[1:])                # If a value was found in the sub-dictionary, return it                if tmp_result is not None:                    return tmp_result                # If no value was found, but the last key exists in the current sub-dictionary, return its value                elif tmp_result is None and keys[-1] in d[keys[0]]:                    return d[keys[0]][keys[-1]]                elif keys[-1] in d:                    return d[keys[-1]]                else:                    return None            else:                # If the first key's value is not a dictionary, return it                return d[keys[0]]        # If the first key is not found, check if the last key exists in the current dictionary and return its value        elif keys[-1] in d:            return d[keys[-1]]        # If neither the first nor the last key leads to a value, return None        else:            return None    # Use the helper function to get the result from the source dictionary    result = get_value(source_dict, paths)    # Return an empty string if no value was found, otherwise return the found value    if result is None:        return ""    else:        return resultdef then_app_call_evaluate_module(method):    """    Decorates a method to process its inference results into a business-specific format.    This decorator enhances a method by adding a post-execution step that processes the method's    inference results. The processing is aimed at transforming the results into a format that meets    specific business requirements. It leverages the `process_inference_results` method of the same    class to perform this transformation. The decorator allows for seamless integration of result    processing within the method's workflow, ensuring that the output directly aligns with business    needs.    Args:        method (Callable): The method to be decorated, expected to produce inference results.    Returns:        Callable: A wrapper function that, upon invocation, executes the original method to generate        inference results, processes these results into the desired business format using the class's        `process_inference_results` method, and returns the processed results.    """    def wrapper(self, *args, **kwargs):        # Execute the decorated method and store its inference results.        results = method(self, *args, **kwargs)        # Process the inference results using the class's `process_inference_results`        # method. The processing is designed to transform the results into a format        if len(self.evaluate_modules) > 0:            return self._evaluate(is_return_async_tasks=False, **results)        else:            return results    return wrapperdef get_dict_values(source_dict: Dict, paths: List, target_variables: List) -> Dict:    """    Retrieves values from a dictionary based on specified paths. If a value is not found at the specified path,    it attempts to retrieve the value associated with the last element of the path list as a key from the parent    dictionary level, continuing until there are no more levels to search or a value is found.    Args:        source_dict: The source dictionary from which to retrieve values.        paths: A list of keys representing the path through the dictionary from the outermost to the innermost level.        target_variables: A list of keys representing the target fields to retrieve from the dictionary.    Returns:        A dictionary with the values found at the specified paths for each target variable.    Raises:        KeyError: If a key in the path is not found in the dictionary and there is no fallback value.    """    results = {}    for target_variable in target_variables:        # Create a deep copy of the paths to avoid modifying the original list.        tmp_paths = copy.deepcopy(paths)        # Append the target variable to the end of the path.        tmp_paths.append(target_variable)        # Retrieve the value from the dictionary using the extended path.        results[target_variable] = get_dict_value(source_dict, tmp_paths)    return resultsdef async_return_type_must_be_callable(method):    """    Decorator to ensure that the method returns a callable object that exists within 'self'.    Args:        method (callable): The method to decorate.    Returns:        callable: The wrapped method.    """    async def wrapper(self, *args, **kwargs):        """        Wrapper function that checks the return value of the method.        Args:            self (object): The instance of the class.            *args: Variable length argument list.            **kwargs: Arbitrary keyword arguments.        Returns:            The result of the method if it's a callable that exists in 'self'.        Raises:            TypeError: If the return value is not a callable.            AttributeError: If the callable is not found in 'self'.        """        # Execute the original method        result = await method(self, *args, **kwargs)        # Check if the return value is callable        if not callable(result):            raise TypeError(f"Return value of {method.__name__} must be a callable.")        # Check if the callable exists in 'self'        if not hasattr(self, result.__name__):            raise AttributeError(f"The callable {result.__name__} is not found in self.")        return result    return wrapperdef return_type_must_be_callable(method):    """    Decorator to ensure that the method returns a callable object that exists within 'self'.    Args:        method (callable): The method to decorate.    Returns:        callable: The wrapped method.    """    def wrapper(self, *args, **kwargs):        """        Wrapper function that checks the return value of the method.        Args:            self (object): The instance of the class.            *args: Variable length argument list.            **kwargs: Arbitrary keyword arguments.        Returns:            The result of the method if it's a callable that exists in 'self'.        Raises:            TypeError: If the return value is not a callable.            AttributeError: If the callable is not found in 'self'.        """        # Execute the original method        result = method(self, *args, **kwargs)        # Check if the return value is callable        if not callable(result):            raise TypeError(f"Return value of {method.__name__} must be a callable.")        # Check if the callable exists in 'self'        if not hasattr(self, result.__name__):            raise AttributeError(f"The callable {result.__name__} is not found in self.")        return result    return wrapperdef async_then_call_func(method):    """    Decorator to ensure that the method returns a callable object that exists within 'self'.    Args:        method (callable): The method to decorate.    Returns:        callable: The wrapped method.    """    async def wrapper(self, *args, **kwargs):        """        Wrapper function that checks the return value of the method.        Args:            self (object): The instance of the class.            *args: Variable length argument list.            **kwargs: Arbitrary keyword arguments.        Returns:            The result of the method if it's a callable that exists in 'self'.        Raises:            TypeError: If the return value is not a callable.            AttributeError: If the callable is not found in 'self'.        """        # Execute the original method        func = await method(self, kwargs)        result = getattr(self, func.__name__)(*args, **kwargs)        return result    return wrapperdef then_call_async_func(method):    """    Decorator to ensure that the method returns a callable object that exists within 'self'.    Args:        method (callable): The method to decorate.    Returns:        callable: The wrapped method.    """    async def wrapper(self, *args, **kwargs):        """        Wrapper function that checks the return value of the method.        Args:            self (object): The instance of the class.            *args: Variable length argument list.            **kwargs: Arbitrary keyword arguments.        Returns:            The result of the method if it's a callable that exists in 'self'.        Raises:            TypeError: If the return value is not a callable.            AttributeError: If the callable is not found in 'self'.        """        # Execute the original method        func = method(self, kwargs)        result = await getattr(self, func.__name__)(*args, **kwargs)        return result    return wrapperdef then_call_func(method):    """    Decorator to ensure that the method returns a callable object that exists within 'self'.    Args:        method (callable): The method to decorate.    Returns:        callable: The wrapped method.    """    def wrapper(self, *args, **kwargs):        """        Wrapper function that checks the return value of the method.        Args:            self (object): The instance of the class.            *args: Variable length argument list.            **kwargs: Arbitrary keyword arguments.        Returns:            The result of the method if it's a callable that exists in 'self'.        Raises:            TypeError: If the return value is not a callable.            AttributeError: If the callable is not found in 'self'.        """        # Execute the original method        func = method(self, kwargs)        result = getattr(self, func.__name__)(*args, **kwargs)        return result    return wrapperdef check_return_be_class_and_replace_name(class_name):    def must_return_base_model_class(func):        """        Decorator to ensure that the decorated function returns a subclass of BaseModel.        Args:            func (function): The function to decorate.        Returns:            function: The decorated function.        """        def wrapper(*args, **kwargs):            """            Wrapper function that checks the return type of the original function.            Args:                *args: Variable length argument list.                **kwargs: Arbitrary keyword arguments.            Returns:                object: The result of the original function if it's a subclass of BaseModel.            Raises:                TypeError: If the result is not a subclass of BaseModel.            """            # Call the original function            result = func(*args, **kwargs)            # Check if the return type is a subclass of BaseModel            if not issubclass(result, BaseModel):                raise TypeError(                    "The return type must be a subclass of BaseModel, but returned: {}"                        .format(result)                )            result.__name__ = class_name            # Return the result if the check passes            return result        return wrapper    return must_return_base_model_classdef async_then_http_request_app_application(method):    """    Decorator that preprocesses the result of an HTTP request method using the chat_application's request preprocess    functionality.    Args:        method (callable): The HTTP request method to decorate.    Returns:        callable: The decorated method.    """    async def wrapper(self, *args, **kwargs):        # Call the original HTTP request method with the provided arguments.        result = await method(self, *args, **kwargs)        # Check if the instance of the class has an attribute 'chat_application'.        if not hasattr(self, 'chat_application'):            # Raise a ValueError if the 'chat_application' attribute is not found.            raise ValueError(f"{type(self).__name__} does not have the object chat_application.")        # Preprocess the result of the HTTP request using the chat_application's request_preprocess method.        if result.get("fast_chat_code", "") == "log":            logger = Logger()            app_result = logger.response_search_log(**result)        else:            app_result = await self.chat_application.request_preprocess(**result)        result = self.process_inference_results(inference_results=result)        # Return the preprocessed result.        if result.get("fast_chat_code", "") == "log":            app_result['fast_chat_code'] = "log"        return result    # Return the wrapper function as the decorated method.    wrapper.__name__ = 'then_http_request_app_application'    return wrapperdef then_http_request_app_application(method):    """    Decorator that preprocesses the result of an HTTP request method using the chat_application's request preprocess    functionality.    Args:        method (callable): The HTTP request method to decorate.    Returns:        callable: The decorated method.    """    async def wrapper(self, *args, **kwargs):        # Call the original HTTP request method with the provided arguments.        result = method(self, *args, **kwargs)        # Check if the instance of the class has an attribute 'chat_application'.        if not hasattr(self, 'chat_application'):            # Raise a ValueError if the 'chat_application' attribute is not found.            raise ValueError(f"{type(self).__name__} does not have the object chat_application.")        # Preprocess the result of the HTTP request using the chat_application's request_preprocess method.        if result.get("fast_chat_code", "") == "log":            logger = Logger()            app_result = logger.response_search_log(**result)        else:            app_result = await self.chat_application.request_preprocess(**result)        # Return the preprocessed result.        if result.get("fast_chat_code", "") == "log":            app_result['fast_chat_code'] = "log"        final_result = self.process_inference_results(req=result, inference_results=app_result)        return final_result    # Return the wrapper function as the decorated method.    wrapper.__name__ = 'then_http_request_app_application'    return wrapperdef then_initialize_request_format(method):    """    Decorator that ensures the definition method for the interface and the initialization    of the HTTP interface are called after the class constructor has executed.    This decorator assumes that the class has methods named `define_request_format` and    `initialize_interface`, and an attribute named `request_format`.    Args:        method: The class method (typically the constructor) to decorate.    Returns:        wrapper: The decorated method with additional logic to initialize the interface.    """    def wrapper(self, *args, **kwargs):        """        The wrapper function that extends the behavior of the decorated method.        It first calls the original method, then checks for the presence of necessary        methods and attributes, and finally initializes the interface.        Args:            self: The instance of the class the method belongs to.            *args: Variable length argument list.            **kwargs: Arbitrary keyword arguments.        Raises:            ValueError: If any of the required methods or attributes are not found in the class.        """        # Call the original method with the provided arguments.        method(self, *args, **kwargs)        # Check if the 'define_request_format' method exists in the class instance.        if not hasattr(self, 'define_request_format'):            raise ValueError(f"{type(self).__name__} does not have the method 'define_request_format'.")        # Check if the 'initialize_interface' method exists in the class instance.        if not hasattr(self, 'initialize_interface'):            raise ValueError(f"{type(self).__name__} does not have the method 'initialize_interface'.")        # Call the 'define_request_format' method to define the request format.        request_format = self.define_request_format()        # Check if the 'request_format' attribute exists in the class instance.        if not hasattr(self, 'request_format'):            raise ValueError(f"{type(self).__name__} does not have the attribute 'request_format'.")        # The original method's return value is preserved, and no explicit return is needed        # if the original method does not return anything.    # Return the wrapper function.    return wrapperdef visit_dict_values(d):    """Recursively visits each value in a dictionary.    This function iterates over each key-value pair in the dictionary. If a value is itself a dictionary, it calls    itself recursively to visit the values in that sub-dictionary. If the value is not a dictionary, it processes the    value (in this example, it prints the value).    Args:        d (dict): The dictionary whose values are to be visited.    """    dt = copy.deepcopy(d)    for key, value in dt.items():        if isinstance(value, dict):            # If the value is a dictionary, call this function recursively            visit_dict_values(value)        elif type(value).__name__ not in ['int', 'str', 'bool', 'float']:            dt[key] = convert_variable_2_normal(value)    return dtdef visit_tuple_values(t):    rt = []    for v in t:        if type(v).__name__ not in ['int', 'str', 'bool', 'float']:            rt.append(convert_variable_2_normal(v))        else:            rt.append(v)    return tuple(rt)def visit_set_values(s):    rs = []    for v in s:        if type(v).__name__ not in ['int', 'str', 'bool', 'float']:            rs.append(convert_variable_2_normal(v))        else:            rs.append(v)    return rsdef visit_list_values(l):    rl = []    for v in l:        if type(v).__name__ not in ['int', 'str', 'bool', 'float']:            rl.append(convert_variable_2_normal(v))        else:            rl.append(v)    return rldef convert_variable_2_normal(variable: Any):    """    Attempts to convert a variable to a dictionary type. If the variable cannot be converted to a dictionary,    it assigns the original variable to variable_dict. If both attempts fail, it sets variable_dict to an empty string.    Args:        variable (Any): The variable to be converted into a dictionary.    Returns:        dict or Any or str: Returns a dictionary representation of the variable if possible.                            If not, returns the original variable. Returns an empty string if both attempts fail.    """    if isinstance(variable, type):        return variable.__name__    elif isinstance(variable, tuple) and len(variable) > 1 and isinstance(variable[1], list) \            and len(variable[1]) > 0 and type(variable[1][0]).__name__ == 'coroutine':        new_variable = (variable[0], [str(v) for v in variable[1]])        return new_variable    elif isinstance(variable, tuple):        return visit_tuple_values(variable)    elif isinstance(variable, dict):        return visit_dict_values(variable)    elif isinstance(variable, list):        return visit_list_values(variable)    elif isinstance(variable, set):        return visit_set_values(variable)    elif type(variable).__name__ in ['int', 'str', 'bool', 'float']:        return variable    else:        return str(variable)def get_current_timestamp():    """    Obtains the current timestamp including the year, month, day, hour, minute, second, and the first three digits of    the microsecond component.    The function uses strftime to format the date and time, then manually appends the first three digits of the    microsecond part of the current time.    Returns:        str: A string representation of the current timestamp in the format 'YYYY-MM-DD HH:MM:SS,mmm' where 'mmm' are        the first three digits of the microsecond component.    """    # Get the current time using datetime.now()    current_time = datetime.now()    # Format the current time up to seconds using strftime and then append the first three digits of the microsecond    # part.    # The comma at the end of the strftime format string is to match the desired output format.    return current_time.strftime('%Y-%m-%d %H:%M:%S,') + str(current_time.microsecond)[:3]def add_call_async_func_2_log(func: Any):    """    Decorator to asynchronously execute a function and log its execution details including start and end timestamps,    input parameters, result, and execution time. It initializes a logger specific to the application and function being executed.    Args:        func (function): The asynchronous function to be wrapped and logged.    Returns:        function: A wrapper function that adds logging to the original function.    """    async def wrapper(self, *args, **kwargs):        # Initialize the logger with the application name, defaulting to 'unknown' if not specified.        logger = Logger(application_name=getattr(self, 'application_name', 'unknown'))        if os.environ.get('JD_ONLINE_PORT', "") != "" and Elasticsearch_Table != "":            es_logger = ESLogger()        # Prepare the log data by inspecting the function's signature to capture its input parameters.        sig = inspect.signature(func)        inputs = {}        index = 0        for param_name, param in sig.parameters.items():            if param_name in kwargs:                inputs[param_name] = kwargs[param_name]                index = -1  # Skip positional arguments if keyword arguments are found.            elif index != -1 and index < len(args):                inputs[param_name] = args[index]                index += 1            elif param.default is not inspect.Parameter.empty:                inputs[param_name] = param.default        inputs_log = convert_variable_2_normal(inputs)        # Initialize log data with timestamps, inputs, and function details.        log_data = {            'start_timestamp': get_current_timestamp(),            'inputs': copy.deepcopy(inputs_log),            'application_name': getattr(self, 'application_name', 'unknown'),            'method_name': func.__name__,            'module_name': getattr(self, 'module_name', 'unknown'),            'class_name': type(self).__name__,            'module_type': getattr(self, 'module_type', 'unknown')        }        start_time = datetime.now()        try:            # Execute the original function and record its result and execution time.            result = await func(self, *args, **kwargs)            if result is None:                return result            end_time = datetime.now()            if func.__name__ in ['async_reply', 'reply', 'async_think', 'think', 'evaluate', 'async_evaluate']:                log_data['composed_prompt'] = await self.chatbot.chain.get_composed_prompt(**kwargs)                print(colorama.Fore.GREEN + log_data['composed_prompt'] + colorama.Style.RESET_ALL)                print(colorama.Fore.BLUE + str(result) + colorama.Style.RESET_ALL)            log_data['end_timestamp'] = get_current_timestamp()            log_data['result'] = convert_variable_2_normal(result)        except Exception as e:            # In case of an exception, log the failure details.            end_time = datetime.now()            log_data['end_timestamp'] = get_current_timestamp()            log_data['spent_time'] = (end_time - start_time).seconds            log_data['result'] = None            logger.write(status='fail', **log_data)            if os.environ.get('JD_ONLINE_PORT', "") != "" and Elasticsearch_Table != "":                es_logger.write(status='fail', **log_data)            raise e  # Optionally re-raise the exception after logging.        # Calculate and log the execution time, then log the successful execution details.        log_data['spent_time'] = (end_time - start_time).seconds        logger.write(status='success', **log_data)        if os.environ.get('JD_ONLINE_PORT', "") != "" and Elasticsearch_Table != "":            es_logger.write(status='success', **log_data)        # Return the result of the original function.        return result    wrapper.__name__ = func.__name__    # Return the decorated wrapper function.    return wrapperdef add_call_func_2_log(func: Any):    """    Decorator to execute a function and log its execution details including start and end timestamps,    input parameters, result, and execution time. It initializes a logger specific to the application and function being executed.    This decorator is intended for synchronous functions, providing detailed logging of the execution context,    inputs, and outputs, which aids in debugging and monitoring application behavior.    Args:        func (function): The synchronous function to be wrapped and logged.    Returns:        function: A wrapper function that adds logging to the original function.    """    def wrapper(self, *args, **kwargs):        # Initialize the logger with the application name, defaulting to 'unknown' if not specified.        logger = Logger(application_name=getattr(self, 'application_name', 'unknown'))        if os.environ.get('JD_ONLINE_PORT', "") != "" and Elasticsearch_Table != "":            es_logger = ESLogger()        # Prepare the log data by inspecting the function's signature to capture its input parameters.        sig = inspect.signature(func)        inputs = {}        index = 0        for param_name, param in sig.parameters.items():            if param_name in kwargs:                inputs[param_name] = kwargs[param_name]                index = -1  # Skip positional arguments if keyword arguments are found.            elif index != -1 and index < len(args):                inputs[param_name] = args[index]                index += 1            elif param.default is not inspect.Parameter.empty:                inputs[param_name] = param.default        # Initialize log data with timestamps, inputs, and function details.        inputs_log = convert_variable_2_normal(inputs)        log_data = {            'start_timestamp': get_current_timestamp(),            'inputs': inputs_log,            'application_name': getattr(self, 'application_name', 'unknown'),            'method_name': func.__name__,            'module_name': getattr(self, 'module_name', 'unknown'),            'class_name': type(self).__name__,            'module_type': getattr(self, 'module_type', 'unknown')        }        start_time = datetime.now()        try:            # Execute the original function and record its result and execution time.            result = func(self, *args, **kwargs)            if result is None:                return result            end_time = datetime.now()            if func.__name__ in ['async_reply', 'reply', 'async_think', 'think', 'evaluate', 'async_evaluate']:                log_data['composed_prompt'] = self.chatbot.chain.get_composed_prompt(**kwargs)                print(colorama.Fore.GREEN + log_data['composed_prompt'] + colorama.Style.RESET_ALL)                print(colorama.Fore.BLUE + str(result) + colorama.Style.RESET_ALL)            log_data['end_timestamp'] = get_current_timestamp()            log_data['result'] = convert_variable_2_normal(result)        except Exception as e:            # In case of an exception, log the failure details.            result = {}            end_time = datetime.now()            log_data['end_timestamp'] = get_current_timestamp()            log_data['spent_time'] = (end_time - start_time).seconds            log_data['result'] = None            if not (isinstance(result, dict) and result.get('fast_chat_code', '') in ['log', 'es_log']):                logger.write(status='fail', **log_data)                if os.environ.get('JD_ONLINE_PORT', "") != "" and Elasticsearch_Table != "":                    es_logger.write(status='fail', **log_data)            raise e  # Optionally re-raise the exception after logging.        # Calculate and log the execution time, then log the successful execution details.        log_data['spent_time'] = (end_time - start_time).seconds        if not (isinstance(result, dict) and result.get('fast_chat_code', '') in ['log', 'es_log']):            logger.write(status='success', **log_data)            if os.environ.get('JD_ONLINE_PORT', "") != "" and Elasticsearch_Table != "":                es_logger.write(status='fail', **log_data)        # Return the result of the original function.        return result    # Return the decorated wrapper function.    return wrapperdef check_setup(func):    """    A decorator that ensures a 'set_up' method is called before the decorated method if it exists.    This is particularly useful for ensuring that certain initializations are performed before    a method's execution. It's a common pattern in test suites and initialization routines.    Args:        func (function): The function to be decorated.    Returns:        function: The wrapper function which will call 'set_up' before the 'func' if applicable.    """    def wrapper(self, *args, **kwargs):        # Check if the instance 'self' has a 'set_up' method and it is callable.        # Also, ensure that 'chatbot' attribute does not exist to prevent redundant setups.        if hasattr(self, 'setup') and callable(getattr(self, 'setup')) and not hasattr(self, 'chatbot'):            # Call the 'setup' method first.            self.setup()        # Proceed to call the original method 'func'.        return func(self, *args, **kwargs)    # Return the wrapper function to be used as the decorated method.    wrapper.__name__ = func.__name__    return wrapperdef async_check_setup(func):    """    A decorator that ensures an asynchronous 'set_up' method is called before the decorated    asynchronous method if it exists.    This decorator is useful for preparing an asynchronous environment before an async method    is executed, such as setting up database connections or performing asynchronous initializations.    Args:        func (coroutine function): The asynchronous function to be decorated.    Returns:        coroutine function: The wrapper coroutine function which will call 'set_up' asynchronously                            before the 'func' if applicable.    """    async def wrapper(self, *args, **kwargs):        # Check if the instance 'self' has a 'set_up' method and it is callable.        # Also, ensure that 'chatbot' attribute does not exist to avoid redundant setup calls.        if hasattr(self, 'setup') and callable(getattr(self, 'setup')) and not hasattr(self, 'chatbot'):            # Asynchronously call the 'set_up' method first.            await self.setup()  # Corrected from self.setup() to self.set_up()        # Proceed to call the original asynchronous method 'func'.        return await func(self, *args, **kwargs)    # Return the wrapper coroutine function to be used as the decorated method.    wrapper.__name__ = func.__name__    return wrapperdef get_test_samples(test_json_file: str, test_case_keys: list = None, test_case_prefixs: str = None):    """    Fetches test case data specified by `test_case_keys` or contains `test_case_prefix` as prefix from the given JSON    file.    This function reads a JSON file specified by `test_json_file` and returns a subset of its content. The subset is    determined either by a list of keys (`test_case_keys`) or a common prefix (`test_case_prefix`) for the keys. If both    `test_case_keys` and `test_case_prefix` are provided, `test_case_keys` takes precedence, and `test_case_prefix` is    ignored.    Args:        test_json_file (str): The path to the JSON file containing test case data.        test_case_keys (list, optional): A list of keys for the specific test cases to fetch. Defaults to None.        test_case_prefixs (list[str], optional): A prefix for test case keys to fetch. If specified, all keys starting with        this prefix are included. Defaults to None.    Returns:        dict: A dictionary containing the requested test case data. If neither `test_case_keys` nor `test_case_prefix`        is provided, returns the entire content of the JSON file.    """    # Open and read the JSON file    with open(test_json_file, "r", encoding="utf-8") as f:        test_samples = json.load(f)    # Filter test samples by test_case_keys if provided and not empty    if isinstance(test_case_keys, list) and len(test_case_keys) > 0:        test_samples = {k: v for k, v in test_samples.items() if k in test_case_keys}    # Filter test samples by test_case_prefix if provided    if isinstance(test_case_prefixs, list) and len(test_case_prefixs) > 0:        test_samples = {k: v for k, v in test_samples.items() if                        any([k.startswith(test_case_prefix) for test_case_prefix in test_case_prefixs])}    return test_samplesdef print_dict(d):    s = json.dumps(d)    rich.print_json(s, highlight=True)def load_json_file(path: str):    """    get a json data from the path of the json file    Args:        path: the path of the json file    Returns: json type data    """    if not os.path.exists(path):        raise ValueError(f"the path {path} not exists.")    # JSON    with open(path, 'r', encoding='utf-8') as file:        data_dict = json.load(file)        return data_dictdef test(url: str,         test_json_file: str,         test_case_keys: list = None,         test_case_prefixs: list = None,         result_path: str = 'data/results',         batch_size: int = 5,         verbose: bool = True):    """    Executes test cases against a specified URL asynchronously and saves the results.    This function reads test cases from a JSON file, sends them to the specified URL, and logs the responses. It allows for batching requests to control the load on the server. The results of these tests are saved to a JSON file with a timestamp in its name.    Args:        url (str): The URL to which the test cases will be sent.        test_json_file (str): The path to the JSON file containing the test cases.        test_case_keys (list[str], optional): Specific keys of test cases to run. Defaults to None.        test_case_prefixs (list[str], optional): Prefixes of test case keys to run. If specified, runs all test cases whose keys start with any of the given prefixes. Defaults to None.        batch_size (int, optional): The number of test cases to send in each batch. Defaults to 5.    Returns:        None. The function saves the test results to a file and prints some details to the console.    """    async def get_case_answer(_session: aiohttp.ClientSession, _case_name: str, _case: typing.Dict):        """        Asynchronously sends a single test case to the specified URL and returns the response.        Args:            _session (aiohttp.ClientSession): The session used for sending the request.            _case_name (str): The name of the test case.            _case (typing.Dict): The test case data.        Returns:            typing.Dict: A dictionary containing the test case name, the original case, the response status, and the response data.        """        async with _session.post(url, headers={'Content-Type': 'application/json'}, json=_case['data']) as response:            # print(f"send url: {url}")            _data = dict()            if response.status == 200:                _data = await response.json()            else:                logging.warning(f"{_case_name}: {response.status}")                if response.status == 400:                    _data = await response.json()            return {                "case_name": _case_name,                "case": _case,                "status": response.status,                "data": _data            }    async def main(_test_samples: dict):        """        The main coroutine that manages the test case execution, batching, and result aggregation.        Args:            _test_samples: Test samples of the current batch        Returns:            list: A list of dictionaries, each containing the result of a test case.        """        async with aiohttp.ClientSession() as session:            tasks = []            gathers = []            for index, (_case_name, case) in enumerate(_test_samples.items()):                task = asyncio.create_task(get_case_answer(session, _case_name, case))                tasks.append(task)            gathers.extend(await asyncio.gather(*tasks))            return gathers    test_samples = get_test_samples(test_json_file=test_json_file,                                    test_case_keys=test_case_keys,                                    test_case_prefixs=test_case_prefixs)    test_sample_names = list(test_samples.keys())    test_sample_names.sort()    test_data = dict() if os.path.isdir(result_path) else load_json_file(result_path)    fail_num = 0    time_stamp = datetime.now().strftime("%Y%m%d%H%M%S")    results_path = os.path.join(result_path, f"test-result-{time_stamp}.json") \        if os.path.isdir(result_path) else result_path    print(f"the test output result file is {colorama.Fore.YELLOW}{results_path}{colorama.Style.RESET_ALL}")    for start in tqdm(range(0, len(test_sample_names), batch_size), total=int(len(test_samples) / batch_size)):        #         batch_names = test_sample_names[start:start + batch_size]        input_sample_names = [v for v in batch_names if v not in test_data]        if len(input_sample_names) <= 0:            continue        input_samples = {k: test_samples[k] for k in input_sample_names}        try:            loop = asyncio.get_event_loop()            results = loop.run_until_complete(main(_test_samples=input_samples))        except Exception as e:            print(f"{e} fails")            fail_num += batch_size            continue        for result in results:            case_name = result['case_name']            status = result["status"]            data = result['data']            case = result['case']            test_data[result['case_name']] = result            if verbose:                print(f"=========={case_name}==========")                print(f"== {status=}")                print(f"==case description:{colorama.Fore.RED}{case.get('description')}{colorama.Style.RESET_ALL}")                # Assuming `print_dict` is a function that pretty prints dictionaries                print_dict(data)        if not os.path.exists(result_path):            os.makedirs(result_path)        with open(results_path, "w", encoding="utf-8") as fp:            json.dump(test_data, fp, ensure_ascii=False)            fp.close()    if fail_num > 0:        print(f"{colorama.Fore.RED}{fail_num}{colorama.Style.RESET_ALL} cases fail.")        success_ratio = "{:.2%}".format((len(test_data) - fail_num) / len(test_data))        print(f"total success ratio:{colorama.Fore.GREEN}{success_ratio}{colorama.Style.RESET_ALL}")    print(f"the test result file is saved in {colorama.Fore.BLUE}{results_path}{colorama.Style.RESET_ALL}")def then_http_backend_request_app_application(method):    """    Decorator that preprocesses the result of an HTTP request method using the chat_application's request preprocess    functionality.    Args:        method (callable): The HTTP request method to decorate.    Returns:        callable: The decorated method.    """    async def wrapper(self, *args, **kwargs):        # Call the original HTTP request method with the provided arguments.        result, background_tasks = method(self, *args, **kwargs)        store = self.set_store_class()()        # Check if the instance of the class has an attribute 'chat_application'.        if not hasattr(self, 'chat_application'):            # Raise a ValueError if the 'chat_application' attribute is not found.            raise ValueError(f"{type(self).__name__} does not have the object chat_application.")        def task(**kwargs):            self.chat_application.background_scheduler = self.update_scheduler(req=result,                                                                               store=store,                                                                               scheduler=self.chat_application.background_scheduler)            res = asyncio.run(self.chat_application.request_preprocess(**kwargs))            return res        # Define an internal function to run the async task        async def async_task():            if result.get("fast_chat_code", "") == "log":                logger = Logger()                app_result = logger.response_search_log(**result)            else:                delay = self.set_request_execution_delay(req=result, store=store, scheduler=self.chat_application.background_scheduler)                slogger.info(f"begin to run BackgroundTask for {result.get('request_id')}")                start_time = datetime.now() + timedelta(seconds=delay)                task_id = self.set_task_id(req=result, store=store, scheduler=self.chat_application.background_scheduler)                if self.chat_application.background_scheduler.get_job(task_id):                    self.chat_application.background_scheduler.remove_job(task_id)                self.chat_application.background_scheduler.add_job(task,                                                                   trigger=DateTrigger(start_time),                                                                   kwargs=result,                                                                   id=task_id)        # Use BackgroundTasks to handle the async task        def run_async_task():            import asyncio            asyncio.run(async_task())        # Assuming `self` has a `background_tasks` attribute or you pass it some other way        try:            slogger.info(f"succeeds to create BackgroundTasks for {result.get('request_id')}")            background_tasks.add_task(run_async_task)        except:            slogger.info(f"fails to create BackgroundTasks for {result.get('request_id')}")            raise ValueError("BackgroundTasks instance is required.")        # Return some immediate response if necessary, or None        self.process_inference_results(req=result,                                       inference_results={"isSuccess": True})    # Return the wrapper function as the decorated method.    wrapper.__name__ = "then_http_backend_request_app_application"    return wrapperdef trans_str_2_messages_form(prompt: str, image_values: list) -> list:    """    Splits the input string into a list of substrings using the provided image_values,    and includes the image_values as individual elements in the resulting list.    Args:        prompt (str): The input string to be split.        image_values (list): A list of separator characters or strings.    Returns:        list: A list containing the substrings and the image_values as individual elements.    """    result = []    start = 0  # Start index of the current substring    i = 0  # Current position in the prompt string    while i < len(prompt):        # Check if the current character or substring matches any separator        for sep in image_values:            if prompt[i:i + len(sep)] == sep:                # Add the substring before the separator                if start < i:                    result.append(prompt[start:i])                # Add the separator as a separate element                result.append(sep)                # Move the start index to the position after the separator                start = i + len(sep)                # Move the current position to skip the separator                i += len(sep)                break        else:            # If no separator is found, move to the next character            i += 1    # Add the remaining substring if any    if start < len(prompt):        result.append(prompt[start:])    ## compose into the messages format    results = [{"type": "image_url", "image_url": {"url": f"{v.split(':')[0]}" + "}"}} if v in image_values else               {"type": "text", "text": f"{v}"} for v in result]    return resultsdef image_to_base64(image_path: str) -> str:    """    Reads an image file and converts it to a Base64 encoded string.    Args:        image_path (str): The path to the image file.    Returns:        str: A Base64 encoded string prefixed with 'data:image/png;base64,'.             Returns None if the file is not found or an error occurs.    Raises:        FileNotFoundError: If the specified image file does not exist.        Exception: If an error occurs while reading or encoding the file.    """    try:        # Open the image file and read its content        with open(image_path, 'rb') as image_file:            # Convert the image content to Base64 encoding            base64_encoded = base64.b64encode(image_file.read())            # Convert the Base64 encoded bytes object to a string            return f"data:image/png;base64,{base64_encoded.decode('utf-8')}"    except FileNotFoundError:        print(f"File {image_path} not found.")        return None    except Exception as e:        print(f"Error reading the file: {e}")        return Nonedef trans_messages_2_str(messages: list) -> str:    """    Converts a list of prompt messages into a single string.    Args:        messages (list): A list of dictionaries representing prompt messages.                         Each dictionary should have a 'type' key (either 'text' or 'image')                         and a 'text' key for text messages.    Returns:        str: A concatenated string of all text messages. If the message type is 'image',             it is replaced with the placeholder "()" (indicating image data is omitted).    """    return "".join([v["text"] if v['type'] == 'text' else "()" for v in messages])def trans_prompt_format(func):    """    A decorator that preprocesses the `prompt` parameter by extracting and evaluating    the substring starting from the 7th character using `ast.literal_eval`.    Args:        func (callable): The function to be decorated.    Returns:        callable: The decorated function.    """    @wraps(func)    def wrapper(*args, **kwargs):        # Check if 'prompt' is in kwargs        prompt = args[1]        try:            # Extract substring starting from the 7th character and evaluate it            if prompt.startswith("Human:"):                processed_prompt = ast.literal_eval(prompt[7:])                args = (args[0], processed_prompt)        except (ValueError, SyntaxError, IndexError) as e:            raise ValueError(f"Failed to preprocess prompt: {e}")        # Call the decorated function with the processed prompt        return func(*args, **kwargs)    return wrapperdef map_field_2_type(field) -> str:    """    Maps a given field to its corresponding class string representation.    Args:        field: The field variable to be mapped.    Returns:        str: The string identifier of the corresponding class.    Raises:        ValueError: If the field type does not match any known types.    Example:        >>> map_field_2_type(FileType())        'File(...)'    """    if isinstance(field, FileType):        return "File(...)"    if getattr(field, "annotation") == UploadFile:        return "File(...)"    elif isinstance(field, FormType):        return "Form(...)"    elif isinstance(field, FieldInfo):        return "Form(...)"    else:        raise ValueError(f"{type(field)}")def strlize(v):    return "\'" + str(v) + "\'"def create_function_from_class(class_object: type,                               func_name: str,                               codes: str,                               args: dict = {},                               kwargs: dict = {},                               global_params: dict = {},                               decorate_codes: str = "",                               import_codes: str = "",                               is_async: bool = False):    """    Creates an interface method based on the provided interface class.    Args:        class_object (type): The class object representing the interface.        func_name (str): The name of the function to be created.        codes (str): The code to be executed within the function.        args (dict): The parameter names (without default value).        kwargs (dict): The parameter and default values for them.        global_params (dict, optional): A dictionary of global parameters for reference. Defaults to an empty dictionary.        decorate_codes (str, optional): Code for decorators to be applied to the function. Defaults to an empty string.        import_codes (str, optional): Code for importing third-party modules. Defaults to an empty string.        is_async bool, optional): if generate async function    Returns:        function: The dynamically created function.    Raises:        KeyError: If the function name is not found in the global parameters after execution.    Example:        >>> class RequestFormat:        >>>     __fields__ = {'param1': Form(...), 'param2': File(...)}        >>> func = create_function_from_dict_keys(        >>>     class_object=RequestFormat,        >>>     func_name="dynamic_function",        >>>     codes="print('Function executed')",        >>>     global_params=globals()        >>> )        >>> func(param1="value1", param2="value2")    """    # Extract field names and types from the class object to use as function parameters    params = [f"{k}:{v}" if len(v) > 0 else f"{k}" for k, v in args.items()]    params.extend([f"{k}={(strlize(v[0]) if isinstance(v[0], str) else v[0])}" if len(        v) < 2 else f"{k}:{v[1]}={strlize(v[0]) if isinstance(v[0], str) else v[0]}" for k, v in kwargs.items()])    params.extend([f"{k}={map_field_2_type(v)}" for k, v in class_object.__fields__.items()])    # Create a string of function parameters    params_str = ", ".join(params)    # Get the current local variable dictionary    context = locals()    # Create a string representation of the local codes for request object    loc_codes = ",\n".join([f"'{k}':{k if map_field_2_type(v) != 'File(...)' else 'await ' + k + '.read()'}" for k, v in                            class_object.__fields__.items()])    loc_codes += "" if len(args) == 0 else ","    loc_codes += ",\n".join([f"'{k}':{k}" for k in args.keys()])    loc_codes += "" if len(kwargs) == 0 else ","    loc_codes += ",\n".join([f"'{k}':{k}" for k in kwargs.keys()])    loc_codes = f"req={{ {loc_codes} }}"    def_type = "async def" if is_async else "def"    # Define the function code as a string    function_code = f"""from fastapi import FastAPI, Form, File{import_codes}{decorate_codes}{def_type} {func_name}({params_str}):    # Create a request dictionary from the parameters    {loc_codes}    # Execute the provided code within the function    {codes}    # Print the request dictionary for debugging    print(req)    """    print(function_code)    # Execute the function code within the provided global parameters    exec(function_code, global_params)    # Return the dynamically created function from the global parameters    return global_params[func_name]def check_has_target_handler(log_file_name, logger):    """Checks if a logger already has a handler for the specified log file.    Used to prevent duplicate log handlers by verifying if a handler with the target    log file name already exists in the logger's core handlers.    Note:        This function checks the internal '_core.handlers' attribute of the logger,        which is a common approach with loguru though technically accessing private members.        The handler matching is done by comparing the '_name' attribute of each handler.    Args:        log_file_name (str): Name of the target log file (without extension) that would            be used to identify the handler. The actual comparison adds '.log' extension.        logger (loguru.Logger): Logger instance to check for existing handlers.    Returns:        bool: True if a handler with matching log file name exists, False otherwise.    Example:        >>> logger = Logger()        >>> logger.add("test.log")        >>> check_has_target_handler("test", logger)        True    """    for key, handler in getattr(getattr(logger, "_core"), "handlers").items():        file_path = getattr(handler, "_name")        file_name = file_path.split("/")[-1]        file_name = file_name.replace("\'", "")        if f"{log_file_name}.log" == file_name:            return True    return False