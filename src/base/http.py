import fastapiimport typingfrom fastapi import APIRouter, Responsefrom abc import ABC, abstractmethod, ABCMetafrom typing import Type, TypeVar, Any, Dictfrom pydantic import BaseModelfrom src.base.utils import check_return_be_class_and_replace_namefrom src.base.utils import store_result_in_attributefrom src.base.utils import then_http_request_app_applicationfrom src.base.utils import async_then_http_request_app_applicationfrom src.base.utils import async_return_type_must_befrom src.base.utils import then_initialize_request_formatfrom src.base.utils import add_call_func_2_logfrom src.base.utils import return_type_must_befrom src.base.utils import add_call_async_func_2_logfrom src.base.utils import convert_async_2_normalRequestFormat = TypeVar('RequestFormat', bound=BaseModel)class _DecorateAllMethods(type):    """A metaclass that decorates all methods of a subclass.    This metaclass iterates over all attributes of a class being created. If an attribute is a callable    (i.e., a method), it checks if the method is overriding a method from its base classes. If it is,    and if the method name matches specific criteria, it applies a decorator to the method. This approach    ensures that methods overriding abstract methods still retain the intended decorators from the superclass.    """    def __new__(mcs, name, bases, dct):        # Iterate over all attributes of the class        for attr, value in dct.items():            # Check if the attribute is a callable (i.e., likely a method)            if callable(value):                is_over_write = False                # Check if this method overrides a method from its base classes                for base in bases:                    if hasattr(base, attr) and getattr(base, attr) is not value:                        is_over_write = True                        break                # Apply specific decorators based on the method's name and whether it overrides a base class method                if attr == 'define_request_format':                    dct[attr] = store_result_in_attribute('request_format')(                        check_return_be_class_and_replace_name('RequestFormat')(add_call_func_2_log(value)))                elif attr == 'gen_request':                    # dct[attr] = convert_async_2_normal(add_call_async_func_2_log(async_then_http_request_app_application(                    #     async_return_type_must_be(Dict)(add_call_async_func_2_log(value)))))                    dct[attr] = add_call_async_func_2_log(then_http_request_app_application(                        return_type_must_be(Dict)(add_call_func_2_log(value))))                elif attr == 'process_inference_results':                    dct[attr] = add_call_func_2_log(value)                elif attr == '__init__':                    dct[attr] = then_initialize_request_format(value)        # Create the new class with the possibly modified dictionary of attributes/methods        return super().__new__(mcs, name, bases, dct)class _CombinedMeta(ABCMeta, _DecorateAllMethods):    """    In order to avoid conflicts caused by other classes inherited by the class that are    not of the same origin as the primitive class, the primitive class and abstract class    ABCMeta are merged to avoid conflicts.    """    passclass HttpInterface(ABC, APIRouter, metaclass=_CombinedMeta):    """    This class provides http interface services for conversation applications, and can easily connect http interfaces    to conversation applications.    """    def __init__(self):        super().__init__()        self.module_type = 'http'    @abstractmethod    def define_request_format(self) -> type:        """        This method is required to return a subclass definition that inherits from BaseModel.        Returns:            Type[RequestFormat]: The subclass of BaseModel that defines the request format.        Raises:            NotImplementedError: This method must be implemented by the subclass.        """        pass    @abstractmethod    def gen_request(self, req: Dict) -> Dict:        """        Preprocesses the incoming request before further processing.        This method is an abstract method that must be implemented by any subclass. It is responsible        for performing any necessary preprocessing steps on the incoming request. The specifics of        the preprocessing are left to the subclass implementation.        Args:            req (T): The incoming request object of type T. The type T can be any type that                     represents a request, such as a data structure or an instance of a custom                     request class.        Returns:            Any: The preprocessed request object. The return type is flexible and depends on the                 preprocessing logic implemented by the subclass. It could be the same type as T,                 a modified version of T, or a completely different type.        Note:            Subclasses must override this method and provide a concrete implementation that defines            the preprocessing steps appropriate for the specific use case.        """        pass  # Subclasses should replace this with the actual preprocessing logic.    @abstractmethod    def process_inference_results(self, inference_results: Any) -> Any:        """        Processes the results from the inference method and returns them for backend developers.        This method is an abstract method that must be implemented by any subclass. It is responsible        for taking the output from the inference method of the chat application, processing it as        necessary, and then returning the processed results. The specifics of the processing should        be defined in the subclass implementation.        Args:            inference_results: The output from the chatApp's inference method.        Returns:            Any: The processed results that will be returned to backend developers.                  The return type is flexible and depends on the processing logic implemented                  by the subclass.        Note:            Subclasses must override this method and provide a concrete implementation.        """        pass  # Subclasses should replace this with actual implementation.    def initialize_interface(self):        """        Initializes the HTTP interface for the class.        This method assumes that the class has an attribute `request_format` that defines        the expected request format and a method `preprocess_request` that processes the        incoming request.        Additionally, it assumes the use of a decorator `@self.post(self.path)` which is        not defined in this snippet. This decorator is likely responsible for handling the        HTTP POST requests at a specific path.        Returns:            None. This method defines an inner function that serves as the interface.        """        request_format = getattr(self, 'request_format')        @self.post(self.path)        async def _interface(req: request_format, response: Response):            """            The formal interface method that handles incoming requests.            This method is designed to be used as an HTTP endpoint and processes the            incoming request using the `preprocess_request` method of the class instance.            Args:                req: The incoming request, expected to be of type `request_format`.                response: The HTTP response object.            Returns:                The processed response or an error message in case of exceptions.            """            try:                # Attempt to preprocess the request and return the result.                res = await self.gen_request(req=req.dict())                return res            except Exception as e:                # In case of an exception, return an error response with a status code and message.                return {                    "code": response.status_code,                    "msg": str(e)                }