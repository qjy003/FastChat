import asyncioimport base64import gzipimport loggingimport jsonimport pickleimport requestsimport osfrom datetime import datefrom datetime import datetimefrom datetime import timedeltafrom src.config import LOGGING_DIRfrom typing import Union, Anylogging.basicConfig()def parse_datetime(date_str):    """    尝试将给定字符串解析为datetime对象。    参数:    date_str: str - 需要解析的日期时间字符串。    返回:    datetime - 成功解析后的datetime对象。    异常:    ValueError - 如果所有支持的格式都无法解析date_str，抛出此异常。    格式支持:    该函数支持多种日期时间格式，包括微秒和毫秒表示。    格式列表如下：    - "%Y-%m-%d %H:%M:%S,%f"    - "%Y-%m-%d %H:%M:%S.%f"    - "%Y-%m-%d %H:%M:%S"    - "%Y-%m-%d %H:%M"    - "%Y-%m-%d %H"    - "%Y-%m-%d"    """    # 遍历支持的日期时间格式列表尝试解析    for fmt in (            "%Y-%m-%d %H:%M:%S,%f", "%Y-%m-%d %H:%M:%S.%f", "%Y-%m-%d %H:%M:%S", "%Y-%m-%d %H:%M", "%Y-%m-%d %H",            "%Y-%m-%d"):        try:            return datetime.strptime(date_str, fmt)  # 尝试使用当前格式解析字符串        except ValueError:            continue  # 如果解析失败，尝试下一个格式    raise ValueError("未知的日期时间格式")  # 如果所有格式都尝试过且失败，抛出异常def check_log_contains(log_str: str, query_contents: Union[list, set, str]) -> bool:    """    Checks if the log string contains the specified content.    Args:        log_str (str): The log data to search within.        query_contents (Union[list, set, str]): The content to search for in the log data.            If a list, all elements must be found for the function to return True.            If a set, at least one element must be found for the function to return True.            If a string, the string must be found for the function to return True.    Returns:        bool: True if the log data contains the specified content, False otherwise.    """    # If the query_contents is a list, check if all elements are in the log_str    if isinstance(query_contents, list):        return all(check_log_contains(log_str, query_content) for query_content in query_contents)    # If the query_contents is a set, check if any element is in the log_str    elif isinstance(query_contents, set):        return any(check_log_contains(log_str, query_content) for query_content in query_contents)    # If the query_contents is a string, check if it is in the log_str    else:        return query_contents in log_strclass JsonFormatter(logging.Formatter):    """    JsonFormatter stores log data in JSON format, facilitating the use of log data for algorithm debugging.    This class subclasses the standard logging.Formatter to output log records in JSON format.    It is particularly useful when log data needs to be parsed or analyzed by machine-readable means.    """    def format(self, record):        """        Format the log record into a JSON string.        This method creates a dictionary with the log record's data, including a formatted timestamp,        and then serializes it to a JSON string. The 'ensure_ascii=False' parameter allows for the        inclusion of non-ASCII characters in the JSON output.        Args:            record (logging.LogRecord): The log record to be formatted.        Returns:            str: A JSON-formatted string representing the log record.        """        # Create a log record dictionary with a formatted timestamp        log_record = {'timestamp': self.formatTime(record)}        # Update the log record dictionary with the rest of the record's attributes        log_record.update(vars(record))        # Serialize the log record dictionary to a JSON string, ensuring non-ASCII characters are preserved        return json.dumps(log_record, ensure_ascii=False)class Logger:    """    Logger class provides logging services with the following capabilities:        1. Writes data into log files within a container.        2. Searches for log data within the container that matches filtering criteria.        3. Retrieves log data from within the container via HTTP requests locally.    This class is designed to manage logging for an application, providing a centralized    location for log data storage and access.    """    def __init__(self, application_name: str = 'data_dialog'):        """        Initialize the Logger instance.        Sets up the logger with a file handler that writes to a log file named after the current date.        The log folder path is expected to be defined in a constant `LOGGING_DIR`.        Args:            application_name (str): The name of the application for which to create the logger.                Defaults to 'data_dialog'.        """        # Define the log file name based on the current date        self.log_file_name = '%s.log' % date.today()        # Set the log folder path from the environment or constant        self.log_folder_path = LOGGING_DIR        # Create a logger instance for the specified application        self.logger = logging.getLogger(application_name)        for handler in self.logger.handlers:            self.logger.removeHandler(handler)        self.logger.setLevel(logging.DEBUG)        # Create a file handler for writing logs to a file        handler = logging.FileHandler(os.path.join(self.log_folder_path, self.log_file_name))        handler.setLevel(logging.DEBUG)        # Use the JsonFormatter to format the log records        formatter = JsonFormatter()        handler.setFormatter(formatter)        # Add the file handler to the logger        self.logger.addHandler(handler)    def write(self, status: str, **kwargs):        """        Writes data to be logged into the log file.        This method logs information based on the provided status. If the status is 'fail',        it logs a warning with the current time, exception information, stack information,        and any additional keyword arguments. Otherwise, it logs a debug message with the        same details.        Args:            status (str): The status of the log entry ('fail' for warnings, any other value for debug).            **kwargs (dict): Additional keyword arguments to be included in the log entry.        Returns:            None        """        if status == 'fail':            self.logger.warning(                datetime.now().strftime("%Y-%m-%d %H:%M:%S"),                exc_info=False,                stack_info=False,                extra=kwargs            )        else:            self.logger.debug(                datetime.now().strftime("%Y-%m-%d %H:%M:%S"),                exc_info=False,                stack_info=False,                extra=kwargs            )    def response_search_log(self, **kwargs):        """        Searches for log entries that match the given filter criteria and returns the        qualifying log data information.        The method iterates through the logs within the specified time range, checking        each line against the provided keyword arguments for matches. Matching log        entries are added to the search results.        Args:            time_zone (tuple): A tuple containing the start and end dates for the search.            query_contents (list[str]): the query_contents        Returns:            dict: A dictionary containing the compressed and base64-encoded search results.        """        time_zone = kwargs.get('time_zone')        query_contents = kwargs.get('query_contents')        start_date = time_zone[0]        end_date = time_zone[1]        start_date_time = parse_datetime(start_date)        end_date_time = parse_datetime(end_date)        start = datetime.strptime(start_date_time.strftime('%Y-%m-%d'), "%Y-%m-%d")        end = datetime.strptime(end_date_time.strftime('%Y-%m-%d'), "%Y-%m-%d")        # If the start and end dates are the same, increment the end date by one day        if start == end:            end = end + timedelta(days=1)        current_date = start        search_results = {}  # Stores the search results        # Iterate through each date in the specified range        while current_date <= end:            current_date_str = current_date.strftime("%Y-%m-%d")            current_log_path = os.path.join(self.log_folder_path, current_date_str + '.log')            # If the log file exists, process it            if os.path.exists(current_log_path):                log_set = set()  # A set to avoid duplicate log entries                for line in open(current_log_path, "r", encoding="UTF-8"):                    data = json.loads(line)                    timestamp_date = parse_datetime(data['timestamp'])                    # Skip the line if the timestamp is outside the search range                    if timestamp_date < start_date_time or timestamp_date > end_date_time:                        continue                    # Check if the line matches all the provided filter criteria                    data_string = json.dumps(data, ensure_ascii=False)                    if not check_log_contains(data_string, query_contents):                        continue                    # If the line is not a duplicate, add it to the results                    if line not in log_set:                        log_set.add(line)                        search_results[len(search_results)] = data            # Increment the current date by one day            current_date += timedelta(days=1)        # Serialize the search results using pickle, compress with gzip, and encode with base64        pres = pickle.dumps(search_results)        gzip_res = gzip.compress(pres)        return {"data": base64.b32encode(gzip_res), 'fast_chat_code': 'log'}    @staticmethod    async def _request_log(url: str, time_zone: tuple, query_contents: Union[list, set, str]):        """        Retrieves log data from a specified URL.        This method constructs a request to the provided URL with the intention of        fetching log data within the specified time zone. It ensures the URL has the        correct format and merges additional keyword arguments into the request body.        Args:            url (str): The network address and interface for the log request.            time_zone (tuple): A tuple indicating the time interval for the log data.            **kwargs (dict): Additional keyword arguments to include in the request body.        Returns:            requests.Response: The Response object from the HTTP request.        """        # Ensure the URL starts with 'http://' if not already present        if not url.startswith('http://'):            url = 'http://' + url        # Ensure the URL ends with '/log' if not already present        if not url.endswith('/log'):            url = url + '/log'        # Print the final URL for debugging purposes        print(url)        # Construct the request data by merging time_zone and any additional kwargs        request_data = {'time_zone': time_zone,                        'query_contents': query_contents}        # Note: This line will not work in an async function. For synchronous use only.        res = requests.post(url, json=request_data)        # Return the Response object        return res    async def request_log(self, urls: list, time_zone: tuple, query_contents: Union[list, set, str],                          log_folder_path: str = 'data/json/'):        """        Concurrently retrieves log data from multiple URLs and aggregates the results.        This method initiates asynchronous requests to retrieve log data from the provided        list of URLs within the specified time zone. It then decodes, decompresses, and        deserializes the responses to aggregate the log data. The aggregated data is        saved to a JSON file in the specified log folder path.        Args:            query_contents: the content we hope exists in the log has            urls (list): A list of URLs from which to fetch log data.            time_zone (tuple): A tuple indicating the time interval for the log data.            log_folder_path (str): The path where the log files are stored.                Default is 'data/json/'.        Returns:            None. The aggregated log data is saved to a file on disk.        """        # List to hold tasks for asynchronous log requests        request_log_tasks = []        # Create a task for each URL to be requested asynchronously        for url in urls:            request_log_tasks.append(                asyncio.create_task(                    self._request_log(                        url=url,                        time_zone=time_zone,                        query_contents=query_contents                    )                )            )        # Wait for all the tasks to complete and gather the results        res_list = await asyncio.gather(*request_log_tasks)        # Aggregate the results into a single dictionary        all_res = {}        for res in res_list:            if res.status_code != 200:                raise ValueError(f"query fails by the code {res.status_code}.")            # Assuming the response is JSON with base64-encoded, gzipped pickle data            d = res.json()            gzip_data = base64.b32decode(d['data'])            pkl_data = gzip.decompress(gzip_data)            bad_cases = pickle.loads(pkl_data)            all_res.update(bad_cases)        # Construct the path for the merged log file        path = os.path.join(log_folder_path, f"merged-data-{datetime.now().strftime('%Y-%m-%d%H%M%S-%f')}.json")        # Output message based on whether log data was found        if len(all_res) > 0:            print(f'Found {len(all_res)} log entries that meet the criteria, saved to {path}')        else:            print('No log entries meeting the criteria were found!')        # Write the aggregated log data to a JSON file        with open(path, "w", encoding="utf-8") as f:            f.write(json.dumps(all_res, ensure_ascii=False))