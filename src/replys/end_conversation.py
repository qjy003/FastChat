# 标准库导入from typing import Any# 应用内基础模块导入from src.base.reply import ReplyModule# 应用内工具模块的导入，合并到一行from src.utils import trim_string, output_json_dataclass EndConversation(ReplyModule):    """    结束对话的对话回复模块    """    def initialize_prompt(self) -> str:        return \            """#角色你是京东物流的销售运营{salesperson_name}，你目前已经完成了与User的沟通，目前你可以礼貌的结束与User的对话。但当User有疑问或者疑惑，或者向你咨询和寻求帮助的时候，也要回复并解答User的疑问或者疑惑，但你不能泄漏任何信息，必须能做到合理应对User的疑问。#正式结束语收到！我快马加鞭为您分配本地的销售，请注意接听电话～#简单结束语好的，祝您生活愉快。#输出结果的格式{{    "reply":"",    "reason":""}}#参考知识{knowledge}#参考内容{newest_reply}#任务你需要严格按照输出结果的格式来输出结果，并按照下面步骤执行来补全reply字段和reason字段，且reply字段的内容作为补全{salesperson_name}回复的内容，且不要再添加其他字段，不要增加以{salesperson_name}命名的主键。补全reply字段内容的理由填写到reason字段。步骤1：你首先需要判断参考内容是否表示了疑问或者疑惑，若参考内容是否表示了疑问或者疑惑，则你需要生成一段{question_reply_prompt}的内容，并将该内容补全到reply字段，并将理由补全到reason字段，并停止执行后续步骤。若User在对话历史当中的最后一句回复没有表示疑问或者疑惑，则执行后续步骤。步骤2：你接着需要根据对话历史当中User的最后一句回复来判断User目前是否在向你咨询并寻求帮助，若User在对话历史当中的最后一句回复明确表达了向你咨询并寻求帮助的意向，则需要将协助并回复User的内容补全reply字段，并将理由补全到reason字段，并停止执行后续步骤。若User在对话历史当中的最后一句回复没有在向你咨询或寻求帮助，则执行后续步骤。步骤3：你接着需要根据对话历史的内容判断正式结束语的内容是否在对话历史当中已经出现，若正式结束语的内容没有在对话历史当中出现，则你需要生成一段参考了正式结束语的回复，并将该回复补全到reply字段，并将理由补全到reason字段。否则你需要参考简单结束语生成一段回复结束和User的对话，并将这段回复补全到reply字段，并将理由补全到reason字段。#对话历史{conversation_history}{salesperson_name}:    """    def process_inference_results(self, inference_results: Any) -> Any:        """        二次处理对话模块执行大模型推理所生成的结果，将处理后的结果返回给对话应用        Args:            inference_results: 大模型推理生成的结果        Returns: 处理后返回给对话应用的结果        """        json_results_str = trim_string(inference_results)        json_results = output_json_data(json_results_str)        return json_results.get('reply', "")